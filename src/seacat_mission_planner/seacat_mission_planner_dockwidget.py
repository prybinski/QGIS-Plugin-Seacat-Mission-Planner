# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SeacatMissionPlannerDockWidget
                                 A QGIS plugin
 Mission planner for FGMG Seacat AUV
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-03-17
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Salvatore Agosta
        email                : s.agosta@fugro.com / salvatore.agosta.survey@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/


"""

import os
import datetime

from PyQt5.QtCore import QSize
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt, QVariant
from qgis._core import QgsField,QgsVectorFileWriter
from qgis.core import QgsProject,QgsCoordinateTransform,QgsCoordinateReferenceSystem, QgsPointXY,QgsWkbTypes,QgsGeometry,QgsPoint, QgsFields, QgsField, QgsFeature,QgsGeometryUtils
import qgis.utils
from qgis.gui import QgsVertexMarker,QgsRubberBand
from PyQt5.QtWidgets import QFileDialog, QMessageBox, QTableWidgetItem
import shapely
from shapely import ops
from shapely.geometry import LineString, Point
import pickle
import numpy
import math

from .AddRowsMapTool import AddRowsMapTool
from .AddGoToMapTool import AddGoToMapTool
from .AddStationKeepingMapTool import AddStationKeepingMapTool
from .seacat_manouvres import *
from .wingline_creator import WingLineCreator
from.resurface_planner import ResurfacePlanner
from .line_spacing_calculator import LineSpacingCalculator
from .camera_calculator import CameraCalculator
from .mission_export_format import MissionExportFormat

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'seacat_mission_planner_dockwidget_base.ui'))


class SeacatMissionPlannerDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, iface, parent=None):
        """Constructor."""
        super(SeacatMissionPlannerDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.iface = iface

        self.canvas = self.iface.mapCanvas()

        self.MissionsFileList = []
        self.Mission = None
        self.rbDict = None
        self.manouvreRbDict = None
        self.RunInRunOutRbDict = None
        self.selectedManouvres = []
        self.MissionToBeSaved = False

        if qgis.utils.Qgis.QGIS_VERSION.split('-')[0] >= '3.30.0':
            self.LinePlanRubber = QgsRubberBand(self.iface.mapCanvas(), QgsWkbTypes.GeometryType.Line)
        else:
            self.LinePlanRubber = QgsRubberBand(self.iface.mapCanvas(), False)

        project = QgsProject.instance()
        project.crsChanged.connect(self.UpdateTransformation)
        self.UpdateTransformation()

        self.AddRowsMapTool = AddRowsMapTool(self.canvas)
        self.EnableAddRowsMapTool = False
        self.AddRowsMapTool.rectangleCreated.connect(self.AddRows)
        self.AddRows_pushButton.clicked.connect(self.AddRows)

        self.AddGoToMapTool = AddGoToMapTool(self.canvas)
        self.EnableAddGoToMapTool = False
        self.AddGoToMapTool.goToCreated.connect(self.AddGoTo)
        self.AddGoTo_pushButton.clicked.connect(self.AddGoTo)

        self.AddStationKeepingMapTool = AddStationKeepingMapTool(self.canvas)
        self.EnableAddStationKeepingMapTool = False
        self.AddStationKeepingMapTool.goToCreated.connect(self.AddStationKeeping)
        self.AddStationKeeping_pushButton.clicked.connect(self.AddStationKeeping)

        self.AddLineFromFeature_pushButton.clicked.connect(self.AddLine)
        self.AddLineWithSurfaceStopsFromFeature_pushButton.clicked.connect(self.AddLineWithSurfaceStops)
        self.AddRowFromFeature_pushButton.clicked.connect(self.CreateRowsFromSelectedFeature)

        self.Reverse_pushButton.clicked.connect(self.ReverseManouvre)
        self.ReverseMission_pushButton.clicked.connect(self.ReverseMission)
        self.CopySettings_pushButton.clicked.connect(self.ChangeManouvreSettings)
        self.MoveUp_pushButton.clicked.connect(self.MoveUp)
        self.MoveDown_pushButton.clicked.connect(self.MoveDown)
        self.Delete_pushButton.clicked.connect(self.Delete)
        self.tableWidget.itemSelectionChanged.connect(self.GetSelectedManouvres)

        self.ExportMission_pushButton.clicked.connect(self.ExportMission)

        self.Missions_comboBox.view().pressed.connect(self.SaveMissionInCaseOfComboBox)
        self.Missions_comboBox.currentTextChanged.connect(self.LoadMission)
        self.NewMission_pushButton.clicked.connect(self.NewMission)
        self.LoadMission_pushButton.clicked.connect(self.OpenMission)
        self.RemoveMission_pushButton.clicked.connect(self.RemoveMission)
        self.SaveMission_pushButton.clicked.connect(self.SaveMission)
        self.SaveMissionSettings_pushButton.clicked.connect(self.SaveMissionSettings)
        self.ShowAllMissions_checkBox.stateChanged.connect(self.ShowAllMissions)
        self.scrollArea_5.setEnabled(False)

        self.MBES_toolButton.clicked.connect(self.ActivateMBES)
        self.SSS_toolButton.clicked.connect(self.ActivateSSS)
        self.SBP_toolButton.clicked.connect(self.ActivateSBP)
        self.OAS_toolButton.clicked.connect(self.ActivateOAS)
        self.MAG_toolButton.clicked.connect(self.ActivateMAG)
        self.PB_toolButton.clicked.connect(self.ActivatePB)
        self.CAM_toolButton.clicked.connect(self.ActivateCAM)
        self.ACOMS_toolButton.clicked.connect(self.ActivateACOMS)

        #Setup Calculators
        self.MBES_calculator_pushButton.clicked.connect(self.MBESCalculator)
        self.Camera_calculator_pushButton.clicked.connect(self.CamCalculator)

        #Remove all wheel events
        self.PlanHeight_comboBox_2.wheelEvent = lambda event: None
        self.MBES_GateMode_comboBox_2.wheelEvent = lambda event: None
        self.MBES_OpMode_comboBox_2.wheelEvent = lambda event: None
        self.MBES_BeamDistrib_comboBox_2.wheelEvent = lambda event: None
        self.MBES_BeamNumber_comboBox_2.wheelEvent = lambda event: None
        self.MBES_Matchfilter_comboBox_2.wheelEvent = lambda event: None
        self.SSS_Gain_comboBox_2.wheelEvent = lambda event: None
        self.SSS_OpMode_comboBox_2.wheelEvent = lambda event: None
        self.CAM_ShowVideo_comboBox_2.wheelEvent = lambda event: None
        self.CAM_ImgCompression_comboBox_2.wheelEvent = lambda event: None
        self.CAM_Format_comboBox_2.wheelEvent = lambda event: None
        self.CAM_Strobe_comboBox_2.wheelEvent = lambda event: None

        self.MissionEndBehavior_comboBox.wheelEvent = lambda event: None
        self.PlanHeight_comboBox.wheelEvent = lambda event: None
        self.MBES_GateMode_comboBox.wheelEvent = lambda event: None
        self.MBES_OpMode_comboBox.wheelEvent = lambda event: None
        self.MBES_BeamDistrib_comboBox.wheelEvent = lambda event: None
        self.MBES_BeamNumber_comboBox.wheelEvent = lambda event: None
        self.MBES_Matchfilter_comboBox.wheelEvent = lambda event: None
        self.SSS_Gain_comboBox.wheelEvent = lambda event: None
        self.SSS_OpMode_comboBox.wheelEvent = lambda event: None
        self.CAM_ShowVideo_comboBox.wheelEvent = lambda event: None
        self.CAM_ImgCompression_comboBox.wheelEvent = lambda event: None
        self.CAM_Format_comboBox.wheelEvent = lambda event: None
        self.CAM_Strobe_comboBox.wheelEvent = lambda event: None

        self.SafeAltitude_doubleSpinBox.wheelEvent = lambda event: None
        self.LowBattery_doubleSpinBox.wheelEvent = lambda event: None
        self.CurveRadius_doubleSpinBox.wheelEvent = lambda event: None
        self.PlanSpeed_doubleSpinBox.wheelEvent = lambda event: None
        self.PlanHeight_doubleSpinBox.wheelEvent = lambda event: None
        self.LineSpacingSet_doubleSpinBox.wheelEvent = lambda event: None
        self.RunInRunOut_spinBox.wheelEvent = lambda event: None
        self.MaxDistance_spinBox.wheelEvent = lambda event: None
        self.StationKeepingDuration_spinBox.wheelEvent = lambda event: None

        self.Acoms_Interval_spinBox.wheelEvent = lambda event: None
        self.Acoms_Repetitions_spinBox.wheelEvent = lambda event: None
        self.MBES_Angle_spinBox.wheelEvent = lambda event: None
        self.MBES_UpperGate_spinBox.wheelEvent = lambda event: None
        self.MBES_LowerGate_spinBox.wheelEvent = lambda event: None
        self.MBES_TxFrequency_spinBox.wheelEvent = lambda event: None
        self.MBES_TxBandwith_spinBox.wheelEvent = lambda event: None
        self.MBES_TxAmplitude_spinBox.wheelEvent = lambda event: None
        self.MBES_TxSweeplenght_spinBox.wheelEvent = lambda event: None
        self.MBES_Matchfilter_comboBox.wheelEvent = lambda event: None
        self.SSS_Range_spinBox.wheelEvent = lambda event: None
        self.SBP_Range_spinBox.wheelEvent = lambda event: None
        self.LFGain_spinBox.wheelEvent = lambda event: None
        self.LFTreshold_spinBox.wheelEvent = lambda event: None
        self.LFContrast_spinBox.wheelEvent = lambda event: None
        self.HFGain_spinBox.wheelEvent = lambda event: None
        self.HFTreshold_spinBox.wheelEvent = lambda event: None
        self.HFContrast_spinBox.wheelEvent = lambda event: None
        self.CAM_Fps_spinBox.wheelEvent = lambda event: None
        self.CAM_Gain_spinBox.wheelEvent = lambda event: None
        self.CAM_ShutterTime_spinBox.wheelEvent = lambda event: None
        self.CAM_StrobeIntensity_spinBox.wheelEvent = lambda event: None

        self.PlanSpeed_doubleSpinBox_2.wheelEvent = lambda event: None
        self.PlanHeight_doubleSpinBox_2.wheelEvent = lambda event: None
        self.StationKeepingDuration_spinBox_2.wheelEvent = lambda event: None

        self.Acoms_Interval_spinBox_2.wheelEvent = lambda event: None
        self.Acoms_Repetitions_spinBox_2.wheelEvent = lambda event: None
        self.MBES_Angle_spinBox_2.wheelEvent = lambda event: None
        self.MBES_UpperGate_spinBox_2.wheelEvent = lambda event: None
        self.MBES_LowerGate_spinBox_2.wheelEvent = lambda event: None
        self.MBES_TxFrequency_spinBox_2.wheelEvent = lambda event: None
        self.MBES_TxBandwith_spinBox_2.wheelEvent = lambda event: None
        self.MBES_TxAmplitude_spinBox_2.wheelEvent = lambda event: None
        self.MBES_TxSweeplenght_spinBox_2.wheelEvent = lambda event: None
        self.MBES_Matchfilter_comboBox_2.wheelEvent = lambda event: None
        self.SSS_Range_spinBox_2.wheelEvent = lambda event: None
        self.SBP_Range_spinBox_2.wheelEvent = lambda event: None
        self.LFGain_spinBox_2.wheelEvent = lambda event: None
        self.LFTreshold_spinBox_2.wheelEvent = lambda event: None
        self.LFContrast_spinBox_2.wheelEvent = lambda event: None
        self.HFGain_spinBox_2.wheelEvent = lambda event: None
        self.HFTreshold_spinBox_2.wheelEvent = lambda event: None
        self.HFContrast_spinBox_2.wheelEvent = lambda event: None
        self.CAM_Fps_spinBox_2.wheelEvent = lambda event: None
        self.CAM_Gain_spinBox_2.wheelEvent = lambda event: None
        self.CAM_ShutterTime_spinBox_2.wheelEvent = lambda event: None
        self.CAM_StrobeIntensity_spinBox_2.wheelEvent = lambda event: None

        if qgis.core.Qgis.versionInt() < 33411:
            #Resize all buttons
            self.AddGoTo_pushButton.setIconSize(
                1 * QSize(self.AddGoTo_pushButton.width(), self.AddGoTo_pushButton.height()))
            self.AddRows_pushButton.setIconSize(
                1 * QSize(self.AddRows_pushButton.width(), self.AddRows_pushButton.height()))
            self.AddLineFromFeature_pushButton.setIconSize(
                1 * QSize(self.AddLineFromFeature_pushButton.width(), self.AddLineFromFeature_pushButton.height()))
            self.AddLineWithSurfaceStopsFromFeature_pushButton.setIconSize(
                1 * QSize(self.AddLineWithSurfaceStopsFromFeature_pushButton.width(), self.AddLineWithSurfaceStopsFromFeature_pushButton.height()))
            self.AddRowFromFeature_pushButton.setIconSize(
                1 * QSize(self.AddRowFromFeature_pushButton.width(), self.AddRowFromFeature_pushButton.height()))
            self.AddStationKeeping_pushButton.setIconSize(
                1 * QSize(self.AddStationKeeping_pushButton.width(), self.AddStationKeeping_pushButton.height()))
            self.Reverse_pushButton.setIconSize(
                1 * QSize(self.Reverse_pushButton.width(), self.Reverse_pushButton.height()))
            self.ReverseMission_pushButton.setIconSize(
                1 * QSize(self.ReverseMission_pushButton.width(), self.ReverseMission_pushButton.height()))
            self.MoveUp_pushButton.setIconSize(
                1 * QSize(self.MoveUp_pushButton.width(), self.MoveUp_pushButton.height()))
            self.MoveDown_pushButton.setIconSize(
                1 * QSize(self.MoveDown_pushButton.width(), self.MoveDown_pushButton.height()))
            self.Delete_pushButton.setIconSize(
                1 * QSize(self.Delete_pushButton.width(), self.Delete_pushButton.height()))
            self.NewMission_pushButton.setIconSize(
                1 * QSize(self.NewMission_pushButton.width(), self.NewMission_pushButton.height()))
            self.LoadMission_pushButton.setIconSize(
                1 * QSize(self.LoadMission_pushButton.width(), self.LoadMission_pushButton.height()))
            self.SaveMission_pushButton.setIconSize(
                1 * QSize(self.SaveMission_pushButton.width(), self.SaveMission_pushButton.height()))
            self.ExportMission_pushButton.setIconSize(
                1 * QSize(self.ExportMission_pushButton.width(), self.ExportMission_pushButton.height()))
            self.RemoveMission_pushButton.setIconSize(
                1 * QSize(self.RemoveMission_pushButton.width(), self.RemoveMission_pushButton.height()))
            self.ShowAllMissions_checkBox.setIconSize(
                1 * QSize(self.ShowAllMissions_checkBox.width(), self.ShowAllMissions_checkBox.height()))
            self.CopySettings_pushButton.setIconSize(
                1 * QSize(self.CopySettings_pushButton.width(), self.CopySettings_pushButton.height()))
        

        self.ActivateAutoApplySettings()

    def ActivateAutoApplySettings(self):
        #Apply Settings When Change manouvre settings value
        self.PlanSpeed_doubleSpinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.StationKeepingDuration_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.PlanHeight_doubleSpinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.PlanHeight_comboBox_2.activated.connect(self.ChangeManouvreSettings)
        self.Acoms_AutoSend_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)
        self.Acoms_Interval_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.Acoms_CurveOnly_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)
        self.Acoms_Repetitions_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.MBES_Active_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)
        self.MBES_GateMode_comboBox_2.activated.connect(self.ChangeManouvreSettings)
        self.MBES_OnLinesOnly_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)
        self.MBES_UpperGate_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.MBES_Angle_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.MBES_LowerGate_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.MBES_OpMode_comboBox_2.activated.connect(self.ChangeManouvreSettings)
        self.MBES_BeamDistrib_comboBox_2.activated.connect(self.ChangeManouvreSettings)
        self.MBES_BeamNumber_comboBox_2.activated.connect(self.ChangeManouvreSettings)
        self.MBES_TxFrequency_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.MBES_TxBandwith_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.MBES_TxAmplitude_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.MBES_TxSweeplenght_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.MBES_Matchfilter_comboBox_2.activated.connect(self.ChangeManouvreSettings)
        self.SSS_Active_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)
        self.SSS_Gain_comboBox_2.activated.connect(self.ChangeManouvreSettings)
        self.SSS_OnLinesOnly_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)
        self.SSS_OpMode_comboBox_2.activated.connect(self.ChangeManouvreSettings)
        self.SSS_Range_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.SBP_Active_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)
        self.SBP_Range_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.SBP_OnLinesOnly_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)
        self.HFGain_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.LFGain_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.HFTreshold_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.LFTreshold_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.HFContrast_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.LFContrast_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.CAM_Active_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)
        self.CAM_ShowVideo_comboBox_2.activated.connect(self.ChangeManouvreSettings)
        self.CAM_Fps_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.CAM_ImgCompression_comboBox_2.activated.connect(self.ChangeManouvreSettings)
        self.CAM_Gain_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.CAM_ShutterTime_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.CAM_Format_comboBox_2.activated.connect(self.ChangeManouvreSettings)
        self.CAM_Strobe_comboBox_2.activated.connect(self.ChangeManouvreSettings)
        self.CAM_StrobeIntensity_spinBox_2.valueChanged.connect(self.ChangeManouvreSettings)
        self.CAM_OnLinesOnly_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)
        self.OAS_Active_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)
        self.MAG_Active_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)
        self.MAG_OnLinesOnly_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)
        self.PB_Active_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)
        self.PB_OnLinesOnly_checkBox_2.stateChanged.connect(self.ChangeManouvreSettings)

    def DeActivateAutoApplySettings(self):
        #Apply Settings When Change manouvre settings value
        self.PlanSpeed_doubleSpinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.StationKeepingDuration_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.PlanHeight_doubleSpinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.PlanHeight_comboBox_2.activated.disconnect(self.ChangeManouvreSettings)
        self.Acoms_AutoSend_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)
        self.Acoms_Interval_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.Acoms_CurveOnly_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)
        self.Acoms_Repetitions_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.MBES_Active_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)
        self.MBES_GateMode_comboBox_2.activated.disconnect(self.ChangeManouvreSettings)
        self.MBES_OnLinesOnly_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)
        self.MBES_UpperGate_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.MBES_Angle_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.MBES_LowerGate_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.MBES_OpMode_comboBox_2.activated.disconnect(self.ChangeManouvreSettings)
        self.MBES_BeamDistrib_comboBox_2.activated.disconnect(self.ChangeManouvreSettings)
        self.MBES_BeamNumber_comboBox_2.activated.disconnect(self.ChangeManouvreSettings)
        self.MBES_TxFrequency_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.MBES_TxBandwith_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.MBES_TxAmplitude_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.MBES_TxSweeplenght_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.MBES_Matchfilter_comboBox_2.activated.disconnect(self.ChangeManouvreSettings)
        self.SSS_Active_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)
        self.SSS_Gain_comboBox_2.activated.disconnect(self.ChangeManouvreSettings)
        self.SSS_OnLinesOnly_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)
        self.SSS_OpMode_comboBox_2.activated.disconnect(self.ChangeManouvreSettings)
        self.SSS_Range_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.SBP_Active_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)
        self.SBP_Range_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.SBP_OnLinesOnly_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)
        self.HFGain_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.LFGain_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.HFTreshold_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.LFTreshold_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.HFContrast_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.LFContrast_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.CAM_Active_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)
        self.CAM_ShowVideo_comboBox_2.activated.disconnect(self.ChangeManouvreSettings)
        self.CAM_Fps_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.CAM_ImgCompression_comboBox_2.activated.disconnect(self.ChangeManouvreSettings)
        self.CAM_Gain_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.CAM_ShutterTime_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.CAM_Format_comboBox_2.activated.disconnect(self.ChangeManouvreSettings)
        self.CAM_Strobe_comboBox_2.activated.disconnect(self.ChangeManouvreSettings)
        self.CAM_StrobeIntensity_spinBox_2.valueChanged.disconnect(self.ChangeManouvreSettings)
        self.CAM_OnLinesOnly_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)
        self.OAS_Active_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)
        self.MAG_Active_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)
        self.MAG_OnLinesOnly_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)
        self.PB_Active_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)
        self.PB_OnLinesOnly_checkBox_2.stateChanged.disconnect(self.ChangeManouvreSettings)

    def setupMissionSettings(self):
        try:
            with open(os.path.join(os.path.dirname(__file__), 'seacatmission.settings'), "rb") as f:
                SettingToLoad = pickle.load(f)
            MissionCriticals = SettingToLoad[0]
            SafeAltitude = SettingToLoad[1]
            MissionEndBehavior = SettingToLoad[2]
            LowBattery = SettingToLoad[3]
            CurveRadius = SettingToLoad[4]
            PlanSpeed = SettingToLoad[5]
            PlanHeight = SettingToLoad[6]
            LineSpacing = SettingToLoad[7]
            RunInRunOut = SettingToLoad[8]
            MaxDistance = SettingToLoad[9]
            StationKeepingDuration = SettingToLoad[10]
            Acoms = SettingToLoad[11]
            MBES = SettingToLoad[12]
            SSS = SettingToLoad[13]
            SBP = SettingToLoad[14]
            Camera = SettingToLoad[15]
            MAG = SettingToLoad[16]
            PB = SettingToLoad[17]
            OAS = SettingToLoad[18]

            self.MBES_MC_checkBox.setChecked(MissionCriticals['MBES'][0])
            self.SSS_MC_checkBox.setChecked(MissionCriticals['SSS'][0])
            self.MAG_MC_checkBox.setChecked(MissionCriticals['MAG'][0])
            self.PB_MC_checkBox.setChecked(MissionCriticals['PB'][0])
            self.CAM_MC_checkBox.setChecked(MissionCriticals['CAM'][0])
            self.OAS_MC_checkBox.setChecked(MissionCriticals['OAS'][0])

            self.SafeAltitude_doubleSpinBox.setValue(SafeAltitude)
            self.MissionEndBehavior_comboBox.setCurrentIndex(MissionEndBehavior)
            self.LowBattery_doubleSpinBox.setValue(LowBattery)
            self.CurveRadius_doubleSpinBox.setValue(CurveRadius)
            self.PlanSpeed_doubleSpinBox.setValue(PlanSpeed)
            self.PlanHeight_doubleSpinBox.setValue(PlanHeight[0])
            self.PlanHeight_comboBox.setCurrentIndex(PlanHeight[1])
            self.LineSpacingSet_doubleSpinBox.setValue(LineSpacing)
            self.RunInRunOut_spinBox.setValue(RunInRunOut)
            self.MaxDistance_spinBox.setValue(MaxDistance)
            self.StationKeepingDuration_spinBox.setValue(StationKeepingDuration)

            self.Acoms_AutoSend_checkBox.setChecked(Acoms.Active)
            self.Acoms_Interval_spinBox.setValue(Acoms.Interval)
            self.Acoms_CurveOnly_checkBox.setChecked(Acoms.InCurveOnly)
            self.Acoms_Repetitions_spinBox.setValue(Acoms.Repetitions)
            self.MBES_Active_checkBox.setChecked(MBES.Active)
            self.MBES_GateMode_comboBox.setCurrentIndex(MBES.GateMode)
            self.MBES_OnLinesOnly_checkBox.setChecked(MBES.OnLinesOnly)
            self.MBES_UpperGate_spinBox.setValue(MBES.UpGate)
            self.MBES_Angle_spinBox.setValue(MBES.Angle)
            self.MBES_LowerGate_spinBox.setValue(MBES.LowGate)
            self.MBES_OpMode_comboBox.setCurrentIndex(MBES.OpMode)
            self.MBES_BeamDistrib_comboBox.setCurrentIndex(MBES.BeamDistribution)
            self.MBES_BeamNumber_comboBox.setCurrentIndex(MBES.BeamNumber)
            self.MBES_TxFrequency_spinBox.setValue(MBES.TxFrequency)
            self.MBES_TxBandwith_spinBox.setValue(MBES.TxBandwith)
            self.MBES_TxAmplitude_spinBox.setValue(MBES.TxAmplitude)
            self.MBES_TxSweeplenght_spinBox.setValue(MBES.TxSweepLenght)
            self.MBES_Matchfilter_comboBox.setCurrentIndex(MBES.TxMatchFilter)
            self.SSS_Active_checkBox.setChecked(SSS.Active)
            self.SSS_Gain_comboBox.setCurrentIndex(SSS.Gain)
            self.SSS_OnLinesOnly_checkBox.setChecked(SSS.OnLinesOnly)
            self.SSS_OpMode_comboBox.setCurrentIndex(SSS.OpMode)
            self.SSS_Range_spinBox.setValue(SSS.Range)
            self.SBP_Active_checkBox.setChecked(SBP.Active)
            self.SBP_Range_spinBox.setValue(SBP.Range)
            self.SBP_OnLinesOnly_checkBox.setChecked(SBP.OnLinesOnly)
            self.HFGain_spinBox.setValue(SBP.HFGain)
            self.LFGain_spinBox.setValue(SBP.LFGain)
            self.HFTreshold_spinBox.setValue(SBP.HFTreshold)
            self.LFTreshold_spinBox.setValue(SBP.LFTreshold)
            self.HFContrast_spinBox.setValue(SBP.HFContrast)
            self.LFContrast_spinBox.setValue(SBP.LFContrast)
            self.CAM_Active_checkBox.setChecked(Camera.Active)
            self.CAM_ShowVideo_comboBox.setCurrentIndex(Camera.ShowVideo)
            self.CAM_Fps_spinBox.setValue(Camera.Framerate)
            self.CAM_ImgCompression_comboBox.setCurrentIndex(Camera.Compression)
            self.CAM_Gain_spinBox.setValue(Camera.Gain)
            self.CAM_ShutterTime_spinBox.setValue(Camera.ShutterTime)
            self.CAM_Format_comboBox.setCurrentIndex(Camera.Format)
            self.CAM_Strobe_comboBox.setCurrentIndex(Camera.Strobe)
            self.CAM_StrobeIntensity_spinBox.setValue(Camera.StrobeIntensity)
            self.CAM_OnLinesOnly_checkBox.setChecked(Camera.OnLinesOnly)
            self.OAS_Active_checkBox.setChecked(OAS.Active)
            self.MAG_Active_checkBox.setChecked(MAG.Active)
            self.MAG_OnLinesOnly_checkBox.setChecked(MAG.OnLinesOnly)
            self.PB_Active_checkBox.setChecked(PB.Active)
            self.PB_OnLinesOnly_checkBox.setChecked(PB.OnLinesOnly)
        except FileNotFoundError:
            pass

    def SaveMissionSettings(self):
        self.RetrieveManouvresSettings()
        SettingsToSave = [self.MissionCriticals,self.SafeAltitude,self.MissionEndBehavior,
                          self.LowBattery,self.CurveRadius,self.PlanSpeed,self.PlanHeight,
                          self.LineSpacing,self.RunInRunOut,self.MaxDistance,self.StationKeepingDuration,
                          self.Acoms,self.MBES,self.SSS,self.SBP,self.Camera,self.MAG,self.PB,self.OAS]
        with open(os.path.join(os.path.dirname(__file__), 'seacatmission.settings') , "wb") as f:
            pickle.dump(SettingsToSave, f)
        ret = QMessageBox.information(self, "Info", 'Mission settings saved as Default',
                                      QMessageBox.Ok)

    def RemoveMission(self):
        Index = self.Missions_comboBox.currentIndex()
        if Index != -1:
            if self.MissionToBeSaved == True:
                ret = QMessageBox.information(self, "Info", 'Current mission was modified, do you want to save it?',
                                              QMessageBox.Yes, QMessageBox.No)
                if ret == QMessageBox.Yes:
                    self.SaveMission()
                self.MissionToBeSaved = False
            self.ShowAllMissions_checkBox.setChecked(False)
            del self.MissionsFileList[Index]
            self.UpdateMissionList()

    def UpdateMissionList(self):
        if self.MissionToBeSaved == True:
            ret = QMessageBox.information(self, "Info", 'Current mission was modified, do you want to save it?',
                                          QMessageBox.Yes, QMessageBox.No)
            if ret == QMessageBox.Yes:
                self.SaveMission()
            self.MissionToBeSaved = False
        self.Missions_comboBox.clear()
        self.MissionsFileList = list(dict.fromkeys(self.MissionsFileList))
        Id = 0
        for mission in self.MissionsFileList:
            self.Missions_comboBox.addItem(os.path.basename(mission).split('.')[0],Id)
            Id =+ 1
        self.LoadMission()

    def LoadMission(self):
        MissionId = self.Missions_comboBox.currentIndex()
        if MissionId != -1:

            with open(self.MissionsFileList[MissionId], "rb") as f:
                Mis = pickle.load(f)
                self.Mission = Mis
                self.MissionToBeSaved = False

        else:
            self.Mission = None
            self.tableWidget.clearContents()
            self.tableWidget.setRowCount(0)
            self.rbDict = None

        self.ShowAllMissions_checkBox.setChecked(False)
        self.DisplayMission()
        self.DisplayManouvres()

    def OpenMission(self):
        MissionId = self.Missions_comboBox.currentIndex() + 1
        missionFiles, _ = QFileDialog.getOpenFileNames(caption='Load seacat mission', filter="Seacat Mission file (*.smf)")
        if missionFiles != []:
            if missionFiles:
                self.ShowAllMissions_checkBox.setChecked(False)
                for mission in missionFiles:
                    self.MissionsFileList.append(mission)
                self.MissionsFileList = list(dict.fromkeys(self.MissionsFileList))
                self.UpdateMissionList()

                self.Missions_comboBox.setCurrentIndex (MissionId)
                if self.Missions_comboBox.currentText() == '':
                    self.Missions_comboBox.setCurrentIndex(MissionId-1)

    def NewMission(self):
        MissionId = self.Missions_comboBox.currentIndex() + 1
        if self.MissionToBeSaved == True:
            ret = QMessageBox.information(self, "Info", 'Current mission was modified, do you want to save it?',
                                          QMessageBox.Yes, QMessageBox.No)
            if ret == QMessageBox.Yes:
                self.SaveMission()
            self.MissionToBeSaved = False
        missionFile, _ = QFileDialog.getSaveFileName(caption='Save seacat mission', filter="Seacat Mission file (*.smf)")
        if missionFile != '.smf' and missionFile != '':
            try:
                missionFile.split('.')[1]
            except:
                missionFile = missionFile + '.smf'

            if missionFile:
                try:
                    os.remove(missionFile)
                except OSError:
                    pass

                self.RetrieveManouvresSettings()
                Mis = Mission(self.MissionCriticals,self.SafeAltitude,self.MissionEndBehavior,
                              self.LowBattery,[])
                with open(missionFile, 'wb') as f:
                    pickle.dump(Mis,f)

                self.ShowAllMissions_checkBox.setChecked(False)
                self.MissionsFileList.append(missionFile)
                self.UpdateMissionList()
                self.Missions_comboBox.setCurrentIndex(MissionId)

    def SaveMissionInCaseOfComboBox(self):
        self.ShowAllMissions_checkBox.setChecked(False)
        if self.MissionToBeSaved == True:
            ret = QMessageBox.information(self, "Info", 'Current mission was modified, do you want to save it?',
                                          QMessageBox.Yes, QMessageBox.No)
            if ret == QMessageBox.Yes:
                self.SaveMission()
            self.MissionToBeSaved = False

    def SaveMission(self):
        MissionId = self.Missions_comboBox.currentIndex()
        if MissionId != -1 and self.Mission is not None:
            with open(self.MissionsFileList[MissionId], "wb") as f:
                pickle.dump(self.Mission, f)
            ret = QMessageBox.information(self, "Info", 'Mission Saved',
                                      QMessageBox.Ok)
            self.MissionToBeSaved = False

    def ExportMission(self):
        if self.Mission is not None and len(self.Mission.ListOfManouvres) != 0 :

            missionFile, _ = QFileDialog.getSaveFileName(directory = self.Missions_comboBox.currentText()+'.txt',caption='Save seacat mission',
                                                         filter="Seacat Mission file (*.txt)")
            if missionFile:

                self.RetrieveManouvresSettings()

                dialog = MissionExportFormat(self)
                GpkgExport = False
                ShpExport = False


                if dialog.exec():
                    GpkgExport = dialog.GPKG
                    ShpExport = dialog.SHP

                try:
                    os.remove(missionFile)
                except OSError:
                    pass

                if GpkgExport == True:
                    fn = os.path.splitext(missionFile)[0]+ '.gpkg'
                    try:
                        os.remove(fn)
                    except OSError:
                        pass
                    layerFields = QgsFields()
                    layerFields.append(QgsField('Manouvre', QVariant.String))
                    layerFields.append(QgsField('Speed kt', QVariant.Double))
                    layerFields.append(QgsField('Altitude', QVariant.Double))
                    layerFields.append(QgsField('Depth', QVariant.Double))
                    layerFields.append(QgsField('MBES', QVariant.String))
                    layerFields.append(QgsField('SSS', QVariant.String))
                    layerFields.append(QgsField('SBP', QVariant.String))
                    layerFields.append(QgsField('MAG', QVariant.String))
                    layerFields.append(QgsField('PlanBlue', QVariant.String))
                    layerFields.append(QgsField('CAMERA', QVariant.String))
                    layerFields.append(QgsField('ACOMS', QVariant.String))
                    layerFields.append(QgsField('OAS', QVariant.String))
                    writerGPKG = QgsVectorFileWriter(fn, "utf-8", layerFields, QgsWkbTypes.MultiLineString,
                                                 QgsCoordinateReferenceSystem("EPSG:4326"), 'GPKG')
                if ShpExport == True:
                    fn = os.path.splitext(missionFile)[0]+ '.shp'
                    fn1 = os.path.splitext(missionFile)[0] + '.cpg'
                    fn2 = os.path.splitext(missionFile)[0] + '.dbf'
                    fn3 = os.path.splitext(missionFile)[0] + '.prj'
                    fn4 = os.path.splitext(missionFile)[0] + '.shx'

                    try:
                        os.remove(fn)
                        os.remove(fn1)
                        os.remove(fn2)
                        os.remove(fn3)
                        os.remove(fn4)

                    except OSError:
                        pass

                    layerFields = QgsFields()
                    layerFields.append(QgsField('Manouvre', QVariant.String))
                    layerFields.append(QgsField('Speed kt', QVariant.Double))
                    layerFields.append(QgsField('Altitude', QVariant.Double))
                    layerFields.append(QgsField('Depth', QVariant.Double))
                    layerFields.append(QgsField('MBES', QVariant.String))
                    layerFields.append(QgsField('SSS', QVariant.String))
                    layerFields.append(QgsField('SBP', QVariant.String))
                    layerFields.append(QgsField('MAG', QVariant.String))
                    layerFields.append(QgsField('PlanBlue', QVariant.String))
                    layerFields.append(QgsField('CAMERA', QVariant.String))
                    layerFields.append(QgsField('ACOMS', QVariant.String))
                    layerFields.append(QgsField('OAS', QVariant.String))
                    writerSHP = QgsVectorFileWriter(fn, "utf-8", layerFields, QgsWkbTypes.MultiLineString,
                                                 QgsCoordinateReferenceSystem("EPSG:4326"), 'ESRI Shapefile')

                lastPoint = None

                with open(missionFile,'wb') as outputFile:
                    BatteryTresholdString = "H LowBatteryState "+str(int(self.LowBattery))+'\r\n'
                    outputFile.write(bytes(BatteryTresholdString, "UTF-8"))
                    if self.MissionEndBehavior == 0:
                        EmergencyEndString = "H EmergencyEnd P" +'\r\n'
                    else:
                        EmergencyEndString = "H EmergencyEnd D" +'\r\n'
                    outputFile.write(bytes(EmergencyEndString,"UTF-8"))
                    SafeAltitudeString = "H SafeAltitude " + str(self.SafeAltitude) +'\r\n\r\n'+'H ReplanningAllowed 0'
                    outputFile.write(bytes(SafeAltitudeString,"UTF-8"))
                    outputFile.write(bytes("\r\n\r\n\r\nH SystemPayload 2" + '\r\n',"UTF-8"))
                    if self.MissionCriticals['OAS']== [True]:
                        MissionCriticalString = '1 C MicronDST'+'\r\n'
                    else:
                        MissionCriticalString = '1 N MicronDST' +'\r\n'
                    outputFile.write(bytes(MissionCriticalString,"UTF-8"))
                    if self.MissionCriticals['SSS']== [True]:
                        MissionCriticalString = '2 C Edgetech2205'+'\r\n'
                    else:
                        MissionCriticalString = '2 N Edgetech2205' +'\r\n'
                    outputFile.write(bytes(MissionCriticalString,"UTF-8"))
                    outputFile.write(bytes("\r\n\r\n\r\nH SwapPayload 7" +'\r\n',"UTF-8"))
                    if self.MissionCriticals['MBES']== [True]:
                        MissionCriticalString = '1 C NorbitWBMS'+'\r\n'
                    else:
                        MissionCriticalString = '1 N NorbitWBMS' +'\r\n'
                    outputFile.write(bytes(MissionCriticalString,"UTF-8"))
                    if self.MissionCriticals['SBP']== [True]:
                        MissionCriticalString = '2 C TritechPSBP'+'\r\n'
                    else:
                        MissionCriticalString = '2 N TritechPSBP' +'\r\n'
                    outputFile.write(bytes(MissionCriticalString,"UTF-8"))
                    if self.MissionCriticals['CAM']== [True]:
                        MissionCriticalString = '3 C UUVCam'+'\r\n'
                    else:
                        MissionCriticalString = '3 N UUVCam' +'\r\n'
                    outputFile.write(bytes(MissionCriticalString,"UTF-8"))
                    if self.MissionCriticals['MAG'] == [True]:
                        MissionCriticalString = '4 C GeometricsG882' +'\r\n'
                    else:
                        MissionCriticalString = '4 N GeometricsG882' +'\r\n'
                    outputFile.write(bytes(MissionCriticalString,"UTF-8"))
                    if self.MissionCriticals['PB'] == [True]:
                        MissionCriticalString = '5 C PlanBlue' +'\r\n'
                    else:
                        MissionCriticalString = '5 N PlanBlue' +'\r\n'
                    outputFile.write(bytes(MissionCriticalString,"UTF-8"))
                    MissionCriticalString = '6 N KrakenMinsas\r\n7 N ATR\r\n\r\n'
                    outputFile.write(bytes(MissionCriticalString,"UTF-8"))
                    outputFile.write(bytes('H EndOfHeader\r\n',"UTF-8"))
                    LineCounter = 1
                    ManouvreCounter = 1
                    PayloadStatus = {'MBES':False,'SSS':False,'SBP':False,'MAG':False,'PB':False,'CAM':False,'OAS':False,'Acoms':False}
                    for manouvre in self.Mission.ListOfManouvres:
                        if manouvre.type == 'Rows':
                            String,LineCounter,PayloadStatus,feat,lastPoint = self.WriteRow(LineCounter,manouvre,PayloadStatus,lastPoint)
                            String = '\r\n\r\n\r\n% '+ manouvre.Name + '--> ' + str(ManouvreCounter) + '\r\n' + String
                        if manouvre.type == 'Line':
                            String, LineCounter, PayloadStatus,feat,lastPoint = self.WriteRow(LineCounter, manouvre, PayloadStatus,lastPoint)
                            String = '\r\n\r\n\r\n% '+ manouvre.Name + '--> ' + str(ManouvreCounter) + '\r\n' + String
                        if manouvre.type == 'LineWStops':
                            String, LineCounter, PayloadStatus,feat,lastPoint = self.WriteRow(LineCounter, manouvre, PayloadStatus,lastPoint)
                            String = '\r\n\r\n\r\n% '+ manouvre.Name + '--> ' + str(ManouvreCounter) + '\r\n' + String
                        if manouvre.type == 'GoTo':
                            String, LineCounter,PayloadStatus,feat,lastPoint = self.WriteGoTo(LineCounter, manouvre, PayloadStatus,lastPoint)
                            String =  '\r\n\r\n\r\n% '+ manouvre.Name + '--> ' + str(ManouvreCounter) + '\r\n' + String
                        if manouvre.type == 'SK':
                            String, LineCounter, PayloadStatus,feat,lastPoint = self.WriteGoTo(LineCounter, manouvre, PayloadStatus,lastPoint)
                            String = '\r\n\r\n\r\n% '+ manouvre.Name + '--> ' + str(ManouvreCounter) + '\r\n' + String
                        if feat != None:
                            if ShpExport == True:
                                writerSHP.addFeature(feat)
                            if GpkgExport == True:
                                writerGPKG.addFeature(feat)
                        ManouvreCounter = ManouvreCounter + 1
                        outputFile.write(bytes(String,"UTF-8"))


                    if ShpExport == True:
                        del writerSHP
                    if GpkgExport == True:
                        del writerGPKG

                    outputFile.write(bytes('\r\n\r\n\r\n% Ending\r\n',"UTF-8"))

                    String = 'S ' + str(LineCounter) + ' O ObstacleAvoidance 0' + '\r\n' + 'S ' + str(
                        LineCounter + 1) + ' R ExternalControl 0' + '\r\n'
                    LineCounter = LineCounter + 2
                    outputFile.write(bytes(String,"UTF-8"))
                    if PayloadStatus['SSS'] == True:
                        String = 'S ' + str(LineCounter) + ' P Edgetech2205 ACTIVE:OFF;RECORDING:OFF' + '\r\n'
                        LineCounter = LineCounter + 1
                        outputFile.write(bytes(String,"UTF-8"))
                    if PayloadStatus['MBES'] == True:
                        String = 'S ' + str(LineCounter) + ' P NorbitWBMS ACTIVE:OFF;RECORDING:OFF' + '\r\n'
                        LineCounter = LineCounter + 1
                        outputFile.write(bytes(String,"UTF-8"))
                    if PayloadStatus['SBP'] == True:
                        String = 'S ' + str(LineCounter) + ' P TritechPSBP ACTIVE:OFF;RECORDING:OFF' + '\r\n'
                        LineCounter = LineCounter + 1
                        outputFile.write(bytes(String,"UTF-8"))
                    if PayloadStatus['CAM'] == True:
                        String = 'S ' + str(LineCounter) + ' P UUVCam RECORDING:OFF' + '\r\n'
                        LineCounter = LineCounter + 1
                        outputFile.write(bytes(String,"UTF-8"))
                    if PayloadStatus['MAG'] == True:
                        String = 'S ' + str(LineCounter) + ' P GeometricsG882 ACTIVE:OFF;RECORDING:OFF' + '\r\n'
                        LineCounter = LineCounter + 1
                        outputFile.write(bytes(String,"UTF-8"))
                    if PayloadStatus['PB'] == True:
                        String = 'S ' + str(LineCounter) + ' P PlanBlue ACTIVE:OFF;RECORDING:OFF' + '\r\n'
                        LineCounter = LineCounter + 1
                        outputFile.write(bytes(String,"UTF-8"))

                    if self.MissionEndBehavior == 0:
                        String = '\r\nC '+ str(LineCounter) + ' Z MissionEnd P' + '\r\n'
                    else:
                        String = '\r\nC ' + str(LineCounter) + ' Z MissionEnd D' + '\r\n'
                    outputFile.write(bytes(String,"UTF-8"))
                ret = QMessageBox.information(self, "Info", 'Mission Exported',
                                              QMessageBox.Ok)

    def WriteGoTo(self,Counter, Manouvre, PayloadStatus,lastPoint):

        String = 'S ' + str(Counter) + ' O ObstacleAvoidance ' + str(int(Manouvre.OAS.Active)) +'\r\n' + 'S ' + str(
            Counter + 1) + ' R ExternalControl 0' +'\r\n'

        if int(Manouvre.OAS.Active) == 1:
            OASAttr = 'ON'
        else:
            OASAttr= 'OFF'

        Counter = Counter + 2
        if Manouvre.Acoms.Active == True and Manouvre.Acoms.Interval > 0:
            String = String + 'S ' + str(Counter) + ' Q Acoms ' + str(int(Manouvre.Acoms.Repetitions)) + ' ' +  str(int(Manouvre.Acoms.Interval)) +'\r\n'
            ACOMSAttr = 'ON'
        else:
            String = String + 'S ' + str(Counter) + ' Q Acoms ' + str(0) +'\r\n'
            ACOMSAttr = 'OFF'


        Counter = Counter + 1


        if Manouvre.SSS.Active == False:
            PayloadStatus['SSS'] = False
            String = String + 'S ' + str(Counter) + ' P Edgetech2205 ACTIVE:OFF;RECORDING:OFF' +'\r\n'
            SSSAttr = 'OFF'
        else:
            PayloadStatus['SSS'] = True
            if Manouvre.InCurve == True and Manouvre.SSS.OnLinesOnly == True:
                String = String + 'S ' + str(Counter) + ' P Edgetech2205 ACTIVE:ON;RECORDING:OFF;OPMODE:' + \
                         self.SSS_OpMode_comboBox.itemText(Manouvre.SSS.OpMode) + ';GAIN:' + self.SSS_Gain_comboBox.itemText(Manouvre.SSS.Gain) + \
                         ';RANGE:' + str(int(Manouvre.SSS.Range)) + '\r\n'
            else:
                String = String + 'S ' + str(Counter) + ' P Edgetech2205 ACTIVE:ON;RECORDING:ON;OPMODE:' + \
                         self.SSS_OpMode_comboBox.itemText(Manouvre.SSS.OpMode) +';GAIN:'+self.SSS_Gain_comboBox.itemText(Manouvre.SSS.Gain) + \
                         ';RANGE:'+str(int(Manouvre.SSS.Range))+'\r\n'
            SSSAttr = 'ON'

        Counter = Counter + 1


        if Manouvre.MBES.Active == False:
            PayloadStatus['MBES'] = False
            String = String + 'S ' + str(Counter) + ' P NorbitWBMS ACTIVE:OFF;RECORDING:OFF' +'\r\n'
            MBESAttr = 'OFF'
        else:
            PayloadStatus['MBES'] = True
            if Manouvre.InCurve == True and Manouvre.MBES.OnLinesOnly == True:

                String = String + 'S ' + str(Counter) + ' P NorbitWBMS ACTIVE:ON;RECORDING:OFF;ANGLE:' + \
                         str(Manouvre.MBES.Angle) + ';OPMODE:' + self.MBES_OpMode_comboBox.itemText(
                    Manouvre.MBES.OpMode) + \
                         ';GATEMODE:' + self.MBES_GateMode_comboBox.itemText(Manouvre.MBES.GateMode) + \
                         ';UPPERGATE:' + str(int(Manouvre.MBES.UpGate)) + ';LOWERGATE:' + str(
                    int(Manouvre.MBES.LowGate)) + \
                         ';BEAMDISTRIB:' + self.MBES_BeamDistrib_comboBox.itemText(
                    Manouvre.MBES.BeamDistribution) + self.MBES_BeamNumber_comboBox.itemText(Manouvre.MBES.BeamNumber) + \
                        ';TXFRQ:' + str(int(Manouvre.MBES.TxFrequency)) + \
                        ';TXBNDW:' + str(int(Manouvre.MBES.TxBandwith)) + \
                        ';TXAMP:' + str(int(Manouvre.MBES.TxAmplitude)) + \
                        ';TXSWPLEN:' + str(int(Manouvre.MBES.TxSweepLenght)) + \
                        ';TXMF:' + str(int(Manouvre.MBES.TxMatchFilter)) + '\r\n'
            else:
                String = String + 'S ' + str(Counter) + ' P NorbitWBMS ACTIVE:ON;RECORDING:ON;ANGLE:' + \
                         str(Manouvre.MBES.Angle) + ';OPMODE:' + self.MBES_OpMode_comboBox.itemText(
                    Manouvre.MBES.OpMode) + \
                         ';GATEMODE:' + self.MBES_GateMode_comboBox.itemText(Manouvre.MBES.GateMode) + \
                         ';UPPERGATE:' + str(int(Manouvre.MBES.UpGate)) + ';LOWERGATE:' + str(
                    int(Manouvre.MBES.LowGate)) + \
                         ';BEAMDISTRIB:' + self.MBES_BeamDistrib_comboBox.itemText(
                    Manouvre.MBES.BeamDistribution) + self.MBES_BeamNumber_comboBox.itemText(Manouvre.MBES.BeamNumber) +\
                        ';TXFRQ:' + str(int(Manouvre.MBES.TxFrequency)) + \
                        ';TXBNDW:' + str(int(Manouvre.MBES.TxBandwith)) + \
                        ';TXAMP:' + str(int(Manouvre.MBES.TxAmplitude)) + \
                        ';TXSWPLEN:' + str(int(Manouvre.MBES.TxSweepLenght)) + \
                        ';TXMF:' + str(int(Manouvre.MBES.TxMatchFilter)) + '\r\n'
            MBESAttr = 'ON'

        Counter = Counter + 1

        if Manouvre.SBP.Active == False:
            PayloadStatus['SBP'] = False
            String = String + 'S ' + str(Counter) + ' P TritechPSBP ACTIVE:OFF;RECORDING:OFF' +'\r\n'
            SBPAttr = 'OFF'
        else:
            PayloadStatus['SBP'] = True
            if Manouvre.InCurve == True and Manouvre.SBP.OnLinesOnly == True:

                String = String + 'S ' + str(Counter) + ' P TritechPSBP ACTIVE:ON;RECORDING:OFF;RANGE:' + \
                         str(int(Manouvre.SBP.Range)) + ';LF_GAIN:' + str(int(Manouvre.SBP.LFGain)) + \
                         ';HF_GAIN:' + str(int(Manouvre.SBP.LFGain)) + \
                         ';LF_THRESHOLD:' + str(int(Manouvre.SBP.LFTreshold)) + \
                         ';HF_THRESHOLD:' + str(int(Manouvre.SBP.HFTreshold)) + \
                         ';LF_CONTRAST:' + str(int(Manouvre.SBP.LFContrast)) + \
                         ';HF_CONTRAST:' + str(int(Manouvre.SBP.HFContrast)) + '\r\n'

            else:

                String = String + 'S ' + str(Counter) + ' P TritechPSBP ACTIVE:ON;RECORDING:ON;RANGE:' + \
                         str(int(Manouvre.SBP.Range)) + ';LF_GAIN:' + str(int(Manouvre.SBP.LFGain)) + \
                         ';HF_GAIN:' + str(int(Manouvre.SBP.LFGain)) + \
                         ';LF_THRESHOLD:' + str(int(Manouvre.SBP.LFTreshold)) + \
                         ';HF_THRESHOLD:' + str(int(Manouvre.SBP.HFTreshold)) + \
                         ';LF_CONTRAST:' + str(int(Manouvre.SBP.LFContrast)) + \
                         ';HF_CONTRAST:' + str(int(Manouvre.SBP.HFContrast)) + '\r\n'
            SBPAttr = 'OFF'

        Counter = Counter + 1


        if Manouvre.Camera.Active == False:
            PayloadStatus['CAM'] = False
            String = String + 'S ' + str(Counter) + ' P UUVCam ACTIVE:OFF;RECORDING:OFF' +'\r\n'
            CAMAttr = 'OFF'
        else:
            PayloadStatus['CAM'] = True
            if Manouvre.InCurve == True and Manouvre.Camera.OnLinesOnly == True:
                String = String + 'S ' + str(Counter) + ' P UUVCam ACTIVE:ON;RECORDING:OFF;FRAMERATE:' + \
                         str(int(Manouvre.Camera.Framerate)) + ';SHOW_VIDEO:' + self.CAM_ShowVideo_comboBox.itemText(Manouvre.Camera.ShowVideo) + \
                         ';GAIN:' + str(int(Manouvre.Camera.Gain)) + \
                         ';IMAGE_FORMAT:' + self.CAM_Format_comboBox.itemText(Manouvre.Camera.Format) + \
                         ';COMPRESSION:' + self.CAM_ImgCompression_comboBox.itemText(Manouvre.Camera.Compression) + \
                         ';SHUTTER_TIME:' + str(int(Manouvre.Camera.ShutterTime)) + \
                         ';STROBE:' + self.CAM_Strobe_comboBox.itemText(Manouvre.Camera.Strobe) + \
                         ';INTENSITY:' + str(int(Manouvre.Camera.StrobeIntensity)) + '\r\n'
            else:
                String = String + 'S ' + str(Counter) + ' P UUVCam ACTIVE:ON;RECORDING:ON;FRAMERATE:' + \
                         str(int(Manouvre.Camera.Framerate)) + ';SHOW_VIDEO:' + self.CAM_ShowVideo_comboBox.itemText(
                    Manouvre.Camera.ShowVideo) + \
                         ';GAIN:' + str(int(Manouvre.Camera.Gain)) + \
                         ';IMAGE_FORMAT:' + self.CAM_Format_comboBox.itemText(Manouvre.Camera.Format) + \
                         ';COMPRESSION:' + self.CAM_ImgCompression_comboBox.itemText(Manouvre.Camera.Compression) + \
                         ';SHUTTER_TIME:' + str(int(Manouvre.Camera.ShutterTime)) + \
                         ';STROBE:' + self.CAM_Strobe_comboBox.itemText(Manouvre.Camera.Strobe) + \
                         ';INTENSITY:' + str(int(Manouvre.Camera.StrobeIntensity)) + '\r\n'
            CAMAttr = 'ON'
        Counter = Counter + 1

        if Manouvre.Mag.Active == False:
            PayloadStatus['MAG'] = False
            String = String + 'S ' + str(Counter) + ' P GeometricsG882 ACTIVE:OFF;RECORDING:OFF' +'\r\n'
            MAGAttr = 'OFF'
        else:
            PayloadStatus['MAG'] = True
            if Manouvre.InCurve == True and Manouvre.Mag.OnLinesOnly == True:
                String = String + 'S ' + str(Counter) + ' P GeometricsG882 ACTIVE:ON;RECORDING:OFF' + '\r\n'
            else:
                String = String + 'S ' + str(Counter) + ' P GeometricsG882 ACTIVE:ON;RECORDING:ON' + '\r\n'
            MAGAttr = 'ON'

        Counter = Counter + 1

        if Manouvre.PlanBlue.Active == False:
            PayloadStatus['PB'] = False
            String = String + 'S ' + str(Counter) + ' P PlanBlue ACTIVE:OFF;RECORDING:OFF' +'\r\n'
            PBAttr = 'OFF'
        else:
            PayloadStatus['PB'] = True
            if Manouvre.InCurve == True and Manouvre.PlanBlue.OnLinesOnly == True:
                String = String + 'S ' + str(Counter) + ' P PlanBlue ACTIVE:ON;RECORDING:OFF' + '\r\n'
            else:
                String = String + 'S ' + str(Counter) + ' P PlanBlue ACTIVE:ON;RECORDING:ON' + '\r\n'
            PBAttr = 'ON'

        Counter = Counter + 1


        String = String + 'S ' + str(Counter) + ' P KrakenMinsas ACTIVE:OFF;RECORDING:OFF;PROCESSING:ON' + '\r\n'

        Counter = Counter + 1

        String = String + 'S ' + str(Counter) + ' P ATR ACTIVE:OFF;RECORDING:OFF' + '\r\n'

        Counter = Counter + 1

        if Manouvre.Height[1] == 0:
            AltString = str(Manouvre.Height[0]) + ' A '
            AltitudeAttr = Manouvre.Height[0]
            DepthAttr = None
        else:
            AltString = str(Manouvre.Height[0]) + ' D '
            AltitudeAttr = None
            DepthAttr = Manouvre.Height[0]

        if Manouvre.type == 'GoTo':
            String = String + 'C ' + str(Counter) + ' A Goto ' + str(round(Manouvre.DestPointY,6))\
                     + ' ' + str(round(Manouvre.DestPointX,6)) +\
                     ' '+ AltString + str(self.KtsToMs(Manouvre.Speed)) + '\r\n'
        if Manouvre.type == 'SK':
            String = String + 'C ' + str(Counter) + ' A Goto ' + str(round(Manouvre.DestPointY, 6)) \
                     + ' ' + str(round(Manouvre.DestPointX, 6)) + \
                     ' ' + AltString + str(self.KtsToMs(Manouvre.Speed)) + '\r\n'
            Counter = Counter + 1
            String = String + 'C ' + str(Counter) + ' K KeepPosition ' + str(round(Manouvre.DestPointY, 6)) \
                     + ' ' + str(round(Manouvre.DestPointX, 6)) + \
                     ' ' + AltString + str(Manouvre.Duration) + '\r\n'
        SpeedAttr = Manouvre.Speed
        Counter = Counter + 10

        if lastPoint == None:
            lastPoint = QgsPoint(Manouvre.DestPointX,Manouvre.DestPointY)
            feat = None
        else:
            feat = QgsFeature()
            feat.setGeometry(QgsGeometry.fromPolyline([lastPoint,QgsPoint(Manouvre.DestPointX,Manouvre.DestPointY)]))
            feat.setAttributes([Manouvre.Name,SpeedAttr,AltitudeAttr,DepthAttr,MBESAttr,SSSAttr,SBPAttr,MAGAttr,PBAttr,CAMAttr,ACOMSAttr,OASAttr])

        lastPoint = QgsPoint(Manouvre.DestPointX, Manouvre.DestPointY)

        return (String, Counter, PayloadStatus,feat,lastPoint)

    def WriteRow(self,Counter, Manouvre, PayloadStatus,lastPoint):
        RecordingStatus = {'MBES':False,'SSS':False,'SBP':False,'MAG':False,'PB':False,'CAM':False,'ACOMS':False}
        String = 'S ' + str(Counter) + ' O ObstacleAvoidance ' + str(int(Manouvre.OAS.Active)) + '\r\n' + 'S ' + str(
            Counter + 1) + ' R ExternalControl 0' + '\r\n'

        if int(Manouvre.OAS.Active) == 1:
            OASAttr = 'ON'
        else:
            OASAttr= 'OFF'

        Counter = Counter + 2
        if Manouvre.Acoms.Active == True and Manouvre.Acoms.Interval > 0 and Manouvre.Acoms.InCurveOnly == False:
            String = String + 'S ' + str(Counter) + ' Q Acoms ' + str(int(Manouvre.Acoms.Repetitions)) + ' ' +  str(int(Manouvre.Acoms.Interval)) + '\r\n'
            RecordingStatus['ACOMS'] = True
            ACOMSAttr = 'ON'
        else:
            String = String + 'S ' + str(Counter) + ' Q Acoms ' + str(0) + '\r\n'
            RecordingStatus['ACOMS'] = False
            ACOMSAttr = 'OFF'


        Counter = Counter + 1

        if Manouvre.SSS.Active == False:
            PayloadStatus['SSS'] = False
            String = String + 'S ' + str(Counter) + ' P Edgetech2205 ACTIVE:OFF;RECORDING:OFF' +'\r\n'
            RecordingStatus['SSS'] = False
            SSSAttr = 'OFF'
        else:
            PayloadStatus['SSS'] = True
            if Manouvre.SSS.OnLinesOnly == True:
                String = String + 'S ' + str(Counter) + ' P Edgetech2205 ACTIVE:ON;RECORDING:OFF;OPMODE:' + \
                         self.SSS_OpMode_comboBox.itemText(Manouvre.SSS.OpMode) + ';GAIN:' + self.SSS_Gain_comboBox.itemText(Manouvre.SSS.Gain) + \
                         ';RANGE:' + str(int(Manouvre.SSS.Range)) + '\r\n'
                RecordingStatus['SSS'] = False
            else:
                String = String + 'S ' + str(Counter) + ' P Edgetech2205 ACTIVE:ON;RECORDING:ON;OPMODE:' + \
                         self.SSS_OpMode_comboBox.itemText(Manouvre.SSS.OpMode) +';GAIN:'+self.SSS_Gain_comboBox.itemText(Manouvre.SSS.Gain) + \
                         ';RANGE:'+str(int(Manouvre.SSS.Range))+'\r\n'
                RecordingStatus['SSS'] = True
            SSSAttr = 'ON'


        Counter = Counter + 1

        if Manouvre.MBES.Active == False:
            PayloadStatus['MBES'] = False
            String = String + 'S ' + str(Counter) + ' P NorbitWBMS ACTIVE:OFF;RECORDING:OFF' + '\r\n'
            RecordingStatus['MBES'] = False
            MBESAttr = 'OFF'
        else:
            PayloadStatus['MBES'] = True
            if Manouvre.MBES.OnLinesOnly == True:
                String = String + 'S ' + str(Counter) + ' P NorbitWBMS ACTIVE:ON;RECORDING:OFF;ANGLE:' + \
                         str(Manouvre.MBES.Angle) + ';OPMODE:' + self.MBES_OpMode_comboBox.itemText(
                    Manouvre.MBES.OpMode) + \
                         ';GATEMODE:' + self.MBES_GateMode_comboBox.itemText(Manouvre.MBES.GateMode) + \
                         ';UPPERGATE:' + str(int(Manouvre.MBES.UpGate)) + ';LOWERGATE:' + str(
                    int(Manouvre.MBES.LowGate)) + \
                         ';BEAMDISTRIB:' + self.MBES_BeamDistrib_comboBox.itemText(
                    Manouvre.MBES.BeamDistribution) + self.MBES_BeamNumber_comboBox.itemText(Manouvre.MBES.BeamNumber) +\
                        ';TXFRQ:' + str(int(Manouvre.MBES.TxFrequency)) + \
                        ';TXBNDW:' + str(int(Manouvre.MBES.TxBandwith)) + \
                        ';TXAMP:' + str(int(Manouvre.MBES.TxAmplitude)) + \
                        ';TXSWPLEN:' + str(int(Manouvre.MBES.TxSweepLenght)) + \
                        ';TXMF:' + str(int(Manouvre.MBES.TxMatchFilter)) + '\r\n'
                RecordingStatus['MBES'] = False
            else:
                String = String + 'S ' + str(Counter) + ' P NorbitWBMS ACTIVE:ON;RECORDING:ON;ANGLE:' + \
                         str(Manouvre.MBES.Angle) + ';OPMODE:' + self.MBES_OpMode_comboBox.itemText(
                    Manouvre.MBES.OpMode) + \
                         ';GATEMODE:' + self.MBES_GateMode_comboBox.itemText(Manouvre.MBES.GateMode) + \
                         ';UPPERGATE:' + str(int(Manouvre.MBES.UpGate)) + ';LOWERGATE:' + str(
                    int(Manouvre.MBES.LowGate)) + \
                         ';BEAMDISTRIB:' + self.MBES_BeamDistrib_comboBox.itemText(
                    Manouvre.MBES.BeamDistribution) + self.MBES_BeamNumber_comboBox.itemText(Manouvre.MBES.BeamNumber) + \
                        ';TXFRQ:' + str(int(Manouvre.MBES.TxFrequency)) + \
                        ';TXBNDW:' + str(int(Manouvre.MBES.TxBandwith)) + \
                        ';TXAMP:' + str(int(Manouvre.MBES.TxAmplitude)) + \
                        ';TXSWPLEN:' + str(int(Manouvre.MBES.TxSweepLenght)) + \
                        ';TXMF:' + str(int(Manouvre.MBES.TxMatchFilter)) + '\r\n'
                RecordingStatus['MBES'] = True
            MBESAttr = 'ON'

        Counter = Counter + 1


        if Manouvre.SBP.Active == False:
            PayloadStatus['SBP'] = False
            String = String + 'S ' + str(Counter) + ' P TritechPSBP ACTIVE:OFF;RECORDING:OFF' +'\r\n'
            RecordingStatus['SBP'] = False
            SBPAttr = 'OFF'
        else:
            PayloadStatus['SBP'] = True
            if Manouvre.SBP.OnLinesOnly == True:

                String = String + 'S ' + str(Counter) + ' P TritechPSBP ACTIVE:ON;RECORDING:OFF;RANGE:' + \
                         str(int(Manouvre.SBP.Range)) + ';LF_GAIN:' + str(int(Manouvre.SBP.LFGain)) + \
                         ';HF_GAIN:' + str(int(Manouvre.SBP.LFGain)) + \
                         ';LF_THRESHOLD:' + str(int(Manouvre.SBP.LFTreshold)) + \
                         ';HF_THRESHOLD:' + str(int(Manouvre.SBP.HFTreshold)) + \
                         ';LF_CONTRAST:' + str(int(Manouvre.SBP.LFContrast)) + \
                         ';HF_CONTRAST:' + str(int(Manouvre.SBP.HFContrast)) + '\r\n'
                RecordingStatus['SBP'] = False

            else:

                String = String + 'S ' + str(Counter) + ' P TritechPSBP ACTIVE:ON;RECORDING:ON;RANGE:' + \
                         str(int(Manouvre.SBP.Range)) + ';LF_GAIN:' + str(int(Manouvre.SBP.LFGain)) + \
                         ';HF_GAIN:' + str(int(Manouvre.SBP.LFGain)) + \
                         ';LF_THRESHOLD:' + str(int(Manouvre.SBP.LFTreshold)) + \
                         ';HF_THRESHOLD:' + str(int(Manouvre.SBP.HFTreshold)) + \
                         ';LF_CONTRAST:' + str(int(Manouvre.SBP.LFContrast)) + \
                         ';HF_CONTRAST:' + str(int(Manouvre.SBP.HFContrast)) + '\r\n'
                RecordingStatus['SBP'] = True
            SBPAttr = 'OFF'

        Counter = Counter + 1

        if Manouvre.Camera.Active == False:
            PayloadStatus['CAM'] = False
            String = String + 'S ' + str(Counter) + ' P UUVCam RECORDING:OFF' + '\r\n'
            RecordingStatus['CAM'] = False
            CAMAttr = 'OFF'
        else:
            PayloadStatus['CAM'] = True
            if Manouvre.Camera.OnLinesOnly == True:
                String = String + 'S ' + str(Counter) + ' P UUVCam RECORDING:OFF;FRAMERATE:' + \
                         str(int(Manouvre.Camera.Framerate)) + ';SHOW_VIDEO:' + self.CAM_ShowVideo_comboBox.itemText(
                    Manouvre.Camera.ShowVideo) + \
                         ';GAIN:' + str(int(Manouvre.Camera.Gain)) + \
                         ';IMAGE_FORMAT:' + self.CAM_Format_comboBox.itemText(Manouvre.Camera.Format) + \
                         ';COMPRESSION:' + self.CAM_ImgCompression_comboBox.itemText(Manouvre.Camera.Compression) + \
                         ';SHUTTER_TIME:' + str(int(Manouvre.Camera.ShutterTime)) + \
                         ';STROBE:' + self.CAM_Strobe_comboBox.itemText(Manouvre.Camera.Strobe) + \
                         ';INTENSITY:' + str(int(Manouvre.Camera.StrobeIntensity)) + '\r\n'
                RecordingStatus['CAM'] = False
            else:
                String = String + 'S ' + str(Counter) + ' P UUVCam RECORDING:ON;FRAMERATE:' + \
                         str(int(Manouvre.Camera.Framerate)) + ';SHOW_VIDEO:' + self.CAM_ShowVideo_comboBox.itemText(
                    Manouvre.Camera.ShowVideo) + \
                         ';GAIN:' + str(int(Manouvre.Camera.Gain)) + \
                         ';IMAGE_FORMAT:' + self.CAM_Format_comboBox.itemText(Manouvre.Camera.Format) + \
                         ';COMPRESSION:' + self.CAM_ImgCompression_comboBox.itemText(Manouvre.Camera.Compression) + \
                         ';SHUTTER_TIME:' + str(int(Manouvre.Camera.ShutterTime)) + \
                         ';STROBE:' + self.CAM_Strobe_comboBox.itemText(Manouvre.Camera.Strobe) + \
                         ';INTENSITY:' + str(int(Manouvre.Camera.StrobeIntensity)) + '\r\n'
                RecordingStatus['CAM'] = True
            CAMAttr = 'ON'

        Counter = Counter + 1

        if Manouvre.Mag.Active == False:
            PayloadStatus['MAG'] = False
            String = String + 'S ' + str(Counter) + ' P GeometricsG882 ACTIVE:OFF;RECORDING:OFF' +'\r\n'
            RecordingStatus['MAG'] = False
            MAGAttr = 'OFF'
        else:
            PayloadStatus['MAG'] = True
            if Manouvre.Mag.OnLinesOnly == True:
                String = String + 'S ' + str(Counter) + ' P GeometricsG882 ACTIVE:ON;RECORDING:OFF' + '\r\n'
                RecordingStatus['MAG'] = False
            else:
                String = String + 'S ' + str(Counter) + ' P GeometricsG882 ACTIVE:ON;RECORDING:ON' + '\r\n'
                RecordingStatus['MAG'] = True
            MAGAttr = 'ON'
        Counter = Counter + 1

        if Manouvre.PlanBlue.Active == False:
            PayloadStatus['PB'] = False
            String = String + 'S ' + str(Counter) + ' P PlanBlue ACTIVE:OFF;RECORDING:OFF' +'\r\n'
            RecordingStatus['PB'] = False
            PBAttr = 'OFF'
        else:
            PayloadStatus['PB'] = True
            if Manouvre.PlanBlue.OnLinesOnly == True:
                String = String + 'S ' + str(Counter) + ' P PlanBlue ACTIVE:ON;RECORDING:OFF' + '\r\n'
                RecordingStatus['PB'] = False
            else:
                String = String + 'S ' + str(Counter) + ' P PlanBlue ACTIVE:ON;RECORDING:ON' + '\r\n'
                RecordingStatus['PB'] = True
            PBAttr = 'ON'
        Counter = Counter + 1

        String = String + 'S ' + str(Counter) + ' P KrakenMinsas ACTIVE:OFF;RECORDING:OFF;PROCESSING:ON' + '\r\n'

        Counter = Counter + 1

        String = String + 'S ' + str(Counter) + ' P ATR ACTIVE:OFF;RECORDING:OFF' + '\r\n'

        Counter = Counter + 1

        if Manouvre.Height[1] == 0:
            AltitudeAttr = Manouvre.Height[0]
            DepthAttr = None
        else:
            AltitudeAttr = None
            DepthAttr = Manouvre.Height[0]

        SpeedAttr = Manouvre.Speed

        if lastPoint == None:
            Line = []
        else:
            Line = [lastPoint]

        SkInLinesWithStop = False    #check if previous manouvre was a SK on surface (Linw W Stops) so Acoms can be reinitiated

        for man in Manouvre.ListOfGoTosOrCurves:

            if man.Acoms.Active == True:
                if man.InCurve == True and RecordingStatus['ACOMS'] == False and man.Acoms.InCurveOnly == True:
                    String = String + 'S ' + str(Counter) + ' Q Acoms ' + str(int(Manouvre.Acoms.Repetitions)) + ' ' +  str(int(Manouvre.Acoms.Interval)) + '\r\n'
                    RecordingStatus['ACOMS'] = True
                    Counter = Counter + 1
                elif man.InCurve == False and RecordingStatus['ACOMS'] == True and man.Acoms.InCurveOnly == True:
                    String = String + 'S ' + str(Counter) + ' Q Acoms ' + str(0) + '\r\n'
                    RecordingStatus['ACOMS'] = False
                    Counter = Counter + 1
                else:
                    if SkInLinesWithStop == True:
                        String = String + 'S ' + str(Counter) + ' Q Acoms ' + str(int(Manouvre.Acoms.Repetitions)) + ' ' +  str(int(Manouvre.Acoms.Interval)) + '\r\n'
                        RecordingStatus['ACOMS'] = True
                        Counter = Counter + 1
                        SkInLinesWithStop = False




            if man.SSS.Active == True:
                if man.InCurve == False and RecordingStatus['SSS'] == False:
                    String = String + 'S ' + str(Counter) + ' P Edgetech2205 ACTIVE:ON;RECORDING:ON;OPMODE:' + \
                            self.SSS_OpMode_comboBox.itemText(
                                man.SSS.OpMode) + ';GAIN:' + self.SSS_Gain_comboBox.itemText(
                        man.SSS.Gain) + \
                            ';RANGE:' + str(int(man.SSS.Range)) + '\r\n'
                    RecordingStatus['SSS'] = True
                    Counter = Counter + 1


                if man.InCurve == True and RecordingStatus['SSS'] == True and man.SSS.OnLinesOnly == True:
                    String = String + 'S ' + str(Counter) + ' P Edgetech2205 ACTIVE:ON;RECORDING:OFF;OPMODE:' + \
                             self.SSS_OpMode_comboBox.itemText(
                                 man.SSS.OpMode) + ';GAIN:' + self.SSS_Gain_comboBox.itemText(
                        man.SSS.Gain) + \
                             ';RANGE:' + str(int(man.SSS.Range)) + '\r\n'
                    RecordingStatus['SSS'] = False
                    Counter = Counter + 1

            if man.MBES.Active == True:
                if man.InCurve == False and RecordingStatus['MBES'] == False :
                    String = String + 'S ' + str(Counter) + ' P NorbitWBMS ACTIVE:ON;RECORDING:ON;ANGLE:' + \
                             str(man.MBES.Angle) + ';OPMODE:' + self.MBES_OpMode_comboBox.itemText(
                        Manouvre.MBES.OpMode) + \
                             ';GATEMODE:' + self.MBES_GateMode_comboBox.itemText(man.MBES.GateMode) + \
                             ';UPPERGATE:' + str(int(man.MBES.UpGate)) + ';LOWERGATE:' + str(
                        int(man.MBES.LowGate)) + \
                             ';BEAMDISTRIB:' + self.MBES_BeamDistrib_comboBox.itemText(
                        man.MBES.BeamDistribution) + self.MBES_BeamNumber_comboBox.itemText(Manouvre.MBES.BeamNumber) + \
                        ';TXFRQ:' + str(int(Manouvre.MBES.TxFrequency)) + \
                        ';TXBNDW:' + str(int(Manouvre.MBES.TxBandwith)) + \
                        ';TXAMP:' + str(int(Manouvre.MBES.TxAmplitude)) + \
                        ';TXSWPLEN:' + str(int(Manouvre.MBES.TxSweepLenght)) + \
                        ';TXMF:' + str(int(Manouvre.MBES.TxMatchFilter)) + '\r\n'
                    RecordingStatus['MBES'] = True
                    Counter = Counter + 1

                if man.InCurve == True and RecordingStatus['MBES'] == True and man.MBES.OnLinesOnly == True:
                    String = String + 'S ' + str(Counter) + ' P NorbitWBMS ACTIVE:ON;RECORDING:OFF;ANGLE:' + \
                             str(man.MBES.Angle) + ';OPMODE:' + self.MBES_OpMode_comboBox.itemText(
                        man.MBES.OpMode) + \
                             ';GATEMODE:' + self.MBES_GateMode_comboBox.itemText(man.MBES.GateMode) + \
                             ';UPPERGATE:' + str(int(man.MBES.UpGate)) + ';LOWERGATE:' + str(
                        int(man.MBES.LowGate)) + \
                             ';BEAMDISTRIB:' + self.MBES_BeamDistrib_comboBox.itemText(
                        man.MBES.BeamDistribution) + self.MBES_BeamNumber_comboBox.itemText(Manouvre.MBES.BeamNumber) +\
                        ';TXFRQ:' + str(int(Manouvre.MBES.TxFrequency)) + \
                        ';TXBNDW:' + str(int(Manouvre.MBES.TxBandwith)) + \
                        ';TXAMP:' + str(int(Manouvre.MBES.TxAmplitude)) + \
                        ';TXSWPLEN:' + str(int(Manouvre.MBES.TxSweepLenght)) + \
                        ';TXMF:' + str(int(Manouvre.MBES.TxMatchFilter)) + '\r\n'
                    RecordingStatus['MBES'] = False
                    Counter = Counter + 1

            if man.SBP.Active == True:
                if man.InCurve == False and RecordingStatus['SBP'] == False :
                    String = String + 'S ' + str(Counter) + ' P TritechPSBP ACTIVE:ON;RECORDING:ON;RANGE:' + \
                             str(int(man.SBP.Range)) + ';LF_GAIN:' + str(int(man.SBP.LFGain)) + \
                             ';HF_GAIN:' + str(int(man.SBP.LFGain)) + \
                             ';LF_THRESHOLD:' + str(int(man.SBP.LFTreshold)) + \
                             ';HF_THRESHOLD:' + str(int(man.SBP.HFTreshold)) + \
                             ';LF_CONTRAST:' + str(int(man.SBP.LFContrast)) + \
                             ';HF_CONTRAST:' + str(int(man.SBP.HFContrast)) + '\r\n'
                    RecordingStatus['SBP'] = True
                    Counter = Counter + 1

                if man.InCurve == True and RecordingStatus['SBP'] == True and man.SBP.OnLinesOnly == True:
                    String = String + 'S ' + str(Counter) + ' P TritechPSBP ACTIVE:ON;RECORDING:OFF;RANGE:' + \
                             str(int(man.SBP.Range)) + ';LF_GAIN:' + str(int(Manouvre.SBP.LFGain)) + \
                             ';HF_GAIN:' + str(int(Manouvre.SBP.LFGain)) + \
                             ';LF_THRESHOLD:' + str(int(man.SBP.LFTreshold)) + \
                             ';HF_THRESHOLD:' + str(int(man.SBP.HFTreshold)) + \
                             ';LF_CONTRAST:' + str(int(man.SBP.LFContrast)) + \
                             ';HF_CONTRAST:' + str(int(man.SBP.HFContrast)) + '\r\n'
                    RecordingStatus['SBP'] = False
                    Counter = Counter + 1

            if man.Camera.Active == True:
                if man.InCurve == False and RecordingStatus['CAM'] == False:
                    String = String + 'S ' + str(Counter) + ' P UUVCam RECORDING:ON;FRAMERATE:' + \
                             str(int(
                                 Manouvre.Camera.Framerate)) + ';SHOW_VIDEO:' + self.CAM_ShowVideo_comboBox.itemText(
                        Manouvre.Camera.ShowVideo) + \
                             ';GAIN:' + str(int(Manouvre.Camera.Gain)) + \
                             ';IMAGE_FORMAT:' + self.CAM_Format_comboBox.itemText(Manouvre.Camera.Format) + \
                             ';COMPRESSION:' + self.CAM_ImgCompression_comboBox.itemText(Manouvre.Camera.Compression) + \
                             ';SHUTTER_TIME:' + str(int(Manouvre.Camera.ShutterTime)) + \
                             ';STROBE:' + self.CAM_Strobe_comboBox.itemText(Manouvre.Camera.Strobe) + \
                             ';INTENSITY:' + str(int(Manouvre.Camera.StrobeIntensity)) + '\r\n'
                    RecordingStatus['CAM'] = True
                    Counter = Counter + 1

                if man.InCurve == True and RecordingStatus['CAM'] == True and man.Camera.OnLinesOnly == True:
                    String = String + 'S ' + str(Counter) + ' P UUVCam RECORDING:OFF;FRAMERATE:' + \
                             str(int(
                                 Manouvre.Camera.Framerate)) + ';SHOW_VIDEO:' + self.CAM_ShowVideo_comboBox.itemText(
                        Manouvre.Camera.ShowVideo) + \
                             ';GAIN:' + str(int(Manouvre.Camera.Gain)) + \
                             ';IMAGE_FORMAT:' + self.CAM_Format_comboBox.itemText(Manouvre.Camera.Format) + \
                             ';COMPRESSION:' + self.CAM_ImgCompression_comboBox.itemText(Manouvre.Camera.Compression) + \
                             ';SHUTTER_TIME:' + str(int(Manouvre.Camera.ShutterTime)) + \
                             ';STROBE:' + self.CAM_Strobe_comboBox.itemText(Manouvre.Camera.Strobe) + \
                             ';INTENSITY:' + str(int(Manouvre.Camera.StrobeIntensity)) + '\r\n'
                    RecordingStatus['CAM'] = False
                    Counter = Counter + 1

            if man.Mag.Active == True:
                if man.InCurve == False and RecordingStatus['MAG'] == False :
                    String = String + 'S ' + str(Counter) + ' P GeometricsG882 ACTIVE:ON;RECORDING:ON' + '\r\n'
                    RecordingStatus['MAG'] = True
                    Counter = Counter + 1

                if man.InCurve == True and RecordingStatus['MAG'] == True and man.Mag.OnLinesOnly == True:
                    String = String + 'S ' + str(Counter) + ' P GeometricsG882 ACTIVE:ON;RECORDING:OFF' + '\r\n'
                    RecordingStatus['MAG'] = False
                    Counter = Counter + 1

            if man.PlanBlue.Active == True:
                if man.InCurve == False and RecordingStatus['PB'] == False :
                        String = String + 'S ' + str(Counter) + ' P PlanBlue ACTIVE:ON;RECORDING:ON' + '\r\n'
                        RecordingStatus['PB'] = True
                        Counter = Counter + 1

                if man.InCurve == True and RecordingStatus['PB'] == True and man.PlanBlue.OnLinesOnly == True:
                    String = String + 'S ' + str(Counter) + ' P PlanBlue ACTIVE:ON;RECORDING:OFF' + '\r\n'
                    RecordingStatus['PB'] = False
                    Counter = Counter + 1

            if man.Height[1] == 0:
                AltString = str(man.Height[0]) + ' A '
            else:
                AltString = str(man.Height[0]) + ' D '
            if man.type == 'GoTo':
                String = String + 'C ' + str(Counter) + ' A Goto ' + str(round(man.DestPointY, 6)) \
                         + ' ' + str(round(man.DestPointX, 6)) + \
                         ' ' + AltString + str(self.KtsToMs(man.Speed)) + '\r\n'
                Counter = Counter + 1

            if man.type == 'SK':
                String = String + 'C ' + str(Counter) + ' A Goto ' + str(round(man.DestPointY, 6)) \
                         + ' ' + str(round(man.DestPointX, 6)) + \
                         ' ' + AltString + str(self.KtsToMs(Manouvre.Speed)) + '\r\n'
                Counter = Counter + 1
                String = String + 'C ' + str(Counter) + ' K KeepPosition ' + str(round(man.DestPointY, 6)) \
                         + ' ' + str(round(man.DestPointX, 6)) + \
                         ' ' + AltString + str(man.Duration) + '\r\n'
                Counter = Counter + 1

                if Manouvre.type == 'LineWStops':
                    SkInLinesWithStop = True


            if man.type == 'Curve':
                String = String + 'C ' + str(Counter) + ' C Curve ' + str(round(man.DestPointY, 6)) \
                         + ' ' + str(round(man.DestPointX, 6)) + ' ' + str(round(man.RotationPointY, 6)) + ' ' + str(round(man.RotationPointX, 6)) + \
                         ' ' + man.Direction + ' '+ AltString + str(self.KtsToMs(Manouvre.Speed)) + '\r\n'
                Counter = Counter + 1
            Line.append(QgsPoint(man.DestPointX,man.DestPointY))




        feat = QgsFeature()
        feat.setGeometry(QgsGeometry.fromPolyline(Line))
        feat.setAttributes([Manouvre.Name, SpeedAttr, AltitudeAttr, DepthAttr, MBESAttr, SSSAttr, SBPAttr, MAGAttr, PBAttr,
                           CAMAttr, ACOMSAttr, OASAttr])
        lastPoint = Line[-1]
        Counter = Counter + 9
        return (String, Counter, PayloadStatus,feat,lastPoint)

    def ShowAllMissions(self):
        if self.ShowAllMissions_checkBox.isChecked() == True and self.MissionsFileList != []:
            if self.rbDict is not None:
                Id = 0
                for mission in self.MissionsFileList:
                    if mission != self.MissionsFileList[self.Missions_comboBox.currentIndex()]:
                        self.canvas.scene().removeItem(self.rbDict[Id])
                        del self.rbDict[Id]
                    Id = Id + 1
            self.rbDict = {}

            if self.RunInRunOutRbDict is not None:
                Id = 0
                for vertex in self.RunInRunOutRbDict:
                    self.canvas.scene().removeItem(self.RunInRunOutRbDict[Id])
                    Id = Id + 1
            self.RunInRunOutRbDict = {}

            RunInRunOutPoints = []

            Id = 0
            for mission in self.MissionsFileList:
                if mission != self.MissionsFileList[self.Missions_comboBox.currentIndex()]:
                    if qgis.utils.Qgis.QGIS_VERSION.split('-')[0] >= '3.30.0':
                        self.rbDict[Id] = QgsRubberBand(self.canvas, QgsWkbTypes.GeometryType.Line)
                    else:
                        self.rbDict[Id] = QgsRubberBand(self.canvas, False)
                    self.rbDict[Id].setColor(QtGui.QColor(30, 136, 229,127))
                    self.rbDict[Id].setWidth(2)
                    self.rbDict[Id].setLineStyle(Qt.PenStyle(Qt.DotLine))
                    with open(mission, "rb") as f:
                        Mis = pickle.load(f)
                    PlanPointsMapCRS = []
                    for manouvre in Mis.ListOfManouvres:
                        if manouvre.type == 'Rows' or manouvre.type == 'Line' or manouvre.type == 'LineWStops':
                            for man in manouvre.ListOfGoTosOrCurves:
                                MapPoint = self.xformMapCrsToWGS84.transform(QgsPointXY(man.DestPointX, man.DestPointY),
                                                                             QgsCoordinateTransform.ReverseTransform)
                                PlanPointsMapCRS.append(QgsPoint(MapPoint))
                                if man.type == 'GoTo' and man.IsRunInRunOutPoint == True or man.type == 'SK':
                                    RunInRunOutPoints.append(MapPoint)

                        if manouvre.type == 'GoTo' or manouvre.type == 'SK':
                            MapPoint = self.xformMapCrsToWGS84.transform(
                                QgsPointXY(manouvre.DestPointX, manouvre.DestPointY),
                                QgsCoordinateTransform.ReverseTransform)


                            PlanPointsMapCRS.append(QgsPoint(MapPoint))
                    self.rbDict[Id].setToGeometry(QgsGeometry.fromPolyline(PlanPointsMapCRS), None)
                Id = Id +1

            Id= 0
            if RunInRunOutPoints != []:
                for point in RunInRunOutPoints:
                    self.RunInRunOutRbDict[Id] = QgsVertexMarker(self.canvas)
                    self.RunInRunOutRbDict[Id].setColor(QtGui.QColor(30, 136, 229))
                    self.RunInRunOutRbDict[Id].setIconSize(15)
                    self.RunInRunOutRbDict[Id].setIconType(QgsVertexMarker.ICON_CIRCLE)  # or ICON_CROSS, ICON_X
                    self.RunInRunOutRbDict[Id].setPenWidth(2)
                    self.RunInRunOutRbDict[Id].setCenter(point)
                    Id = Id + 1
        else:
            if self.rbDict is not None:
                Id = 0
                for mission in self.MissionsFileList:
                    if mission != self.MissionsFileList[self.Missions_comboBox.currentIndex()]:
                        self.canvas.scene().removeItem(self.rbDict[Id])
                        del self.rbDict[Id]
                    Id = Id + 1
                if self.rbDict == {}:
                    self.rbDict = None

            if self.RunInRunOutRbDict is not None:
                Id = 0
                for vertex in self.RunInRunOutRbDict:
                    self.canvas.scene().removeItem(self.RunInRunOutRbDict[Id])
                    Id = Id + 1
            self.RunInRunOutRbDict = None

    def DisplayMission(self):

        try:
            self.tableWidget.itemChanged.disconnect(self.ChangeManouvreName)
        except:
            pass

        self.EstDuration_label.setText('Est. duration:')
        self.tableWidget.clearContents()
        self.tableWidget.setRowCount(0)
        self.LinePlanRubber.reset(QgsWkbTypes.LineGeometry)

        try:
            self.canvas.scene().removeItem(self.StartPlanMarker)
            self.canvas.scene().removeItem(self.EndPlanMarker)
        except:
            pass

        if self.Mission is not None and len(self.Mission.ListOfManouvres) != 0 :
            Len_self_Mission_ListOfManouvres = len(self.Mission.ListOfManouvres)
            self.tableWidget.setRowCount(Len_self_Mission_ListOfManouvres)

              # False = not a polygon
            self.LinePlanRubber.setColor(QtGui.QColor(255, 193, 7))
            self.LinePlanRubber.setWidth(2)
            self.LinePlanRubber.setLineStyle(Qt.PenStyle(Qt.DotLine))

            self.StartPlanMarker = QgsVertexMarker(self.canvas)
            self.EndPlanMarker = QgsVertexMarker(self.canvas)
            self.StartPlanMarker.setColor(QtGui.QColor(0, 255, 0,127))
            self.StartPlanMarker.setIconSize(20)
            self.StartPlanMarker.setIconType(QgsVertexMarker.ICON_X)  # or ICON_CROSS, ICON_X
            self.StartPlanMarker.setPenWidth(4)
            self.EndPlanMarker.setColor(QtGui.QColor(255, 0, 0,127))
            self.EndPlanMarker.setIconSize(20)
            self.EndPlanMarker.setIconType(QgsVertexMarker.ICON_BOX)  # or ICON_CROSS, ICON_X
            self.EndPlanMarker.setPenWidth(4)

            id = 0
            PlanPointsMapCRS = []
            TotalTime = datetime.timedelta(seconds=0)
            LastPoint = None
            LastPointWGS84 = None
            FirstPointWGS84 = None
            xformWGS84ToUTM = None
            Direction = None
            for manouvre in self.Mission.ListOfManouvres:
                if manouvre.type == 'Rows' or manouvre.type == 'Line'or manouvre.type == 'LineWStops':
                    RowPoints = []
                    StationKeepings_time = 0
                    i = 0
                    lastrowpoint = len(manouvre.ListOfGoTosOrCurves)-1
                    SpeedMs = self.KtsToMs(manouvre.Speed)
                    for man in manouvre.ListOfGoTosOrCurves:
                        MapPoint =  self.xformMapCrsToWGS84.transform(QgsPointXY(man.DestPointX, man.DestPointY), QgsCoordinateTransform.ReverseTransform)

                        if man.type == 'SK':
                            StationKeepings_time = StationKeepings_time + man.Duration
                        if i == 0 and id == 0:
                            self.StartPlanMarker.setCenter(MapPoint)
                            UTMEPSG = self.get_utm_zoneEPSG(man.DestPointX, man.DestPointY)
                            crsOrig = QgsCoordinateReferenceSystem("EPSG:4326")
                            crsDest = QgsCoordinateReferenceSystem(UTMEPSG)
                            transformContext = QgsProject.instance().transformContext()
                            xformWGS84ToUTM = QgsCoordinateTransform(crsOrig, crsDest, transformContext)

                        UTMPoint = xformWGS84ToUTM.transform(QgsPointXY(man.DestPointX, man.DestPointY))

                        if i == 0 and manouvre.type == 'Line' or i == 0 and manouvre.type == 'LineWStops':
                            FirstPointWGS84 = QgsPointXY(man.DestPointX, man.DestPointY)

                        if i == 0:
                            if LastPoint != None:
                                dist = math.dist(LastPoint,UTMPoint)
                                timeToAdd = datetime.timedelta(seconds=round(dist/SpeedMs))
                                TotalTime = TotalTime + timeToAdd

                        if i == lastrowpoint and manouvre.type == 'Line' or i == lastrowpoint and manouvre.type == 'LineWStops':
                            Direction = self.degToCompass(FirstPointWGS84.azimuth(QgsPointXY(man.DestPointX, man.DestPointY)))

                        if id == Len_self_Mission_ListOfManouvres-1 and i == lastrowpoint:
                            self.EndPlanMarker.setCenter(MapPoint)

                        LastPoint = UTMPoint
                        LastPointWGS84 = QgsPointXY(man.DestPointX, man.DestPointY)
                        RowPoints.append(UTMPoint)
                        PlanPointsMapCRS.append(QgsPoint(MapPoint))
                        i = i+1

                    RowLenght = LineString(RowPoints).length
                    RowTime = datetime.timedelta(seconds=round(RowLenght/SpeedMs)) + datetime.timedelta(seconds=StationKeepings_time)
                    TotalTime = TotalTime + RowTime
                    self.tableWidget.setItem(id, 0, QTableWidgetItem(manouvre.Name))
                    self.tableWidget.setItem(id, 2, QTableWidgetItem(str(RowTime)))
                    if manouvre.type == 'Line' or manouvre.type =='LineWStops':
                        self.tableWidget.setItem(id, 1, QTableWidgetItem(Direction))
                    elif manouvre.type == 'Rows':
                        self.tableWidget.setItem(id, 1, QTableWidgetItem('N/A'))


                if manouvre.type == 'GoTo' or manouvre.type == 'SK':
                    MapPoint = self.xformMapCrsToWGS84.transform(QgsPointXY(manouvre.DestPointX, manouvre.DestPointY),
                                                                 QgsCoordinateTransform.ReverseTransform)
                    if id == 0:
                        self.StartPlanMarker.setCenter(MapPoint)
                        UTMEPSG = self.get_utm_zoneEPSG(manouvre.DestPointX, manouvre.DestPointY)
                        crsOrig = QgsCoordinateReferenceSystem("EPSG:4326")
                        crsDest = QgsCoordinateReferenceSystem(UTMEPSG)
                        transformContext = QgsProject.instance().transformContext()
                        xformWGS84ToUTM = QgsCoordinateTransform(crsOrig, crsDest, transformContext)

                    UTMPoint = xformWGS84ToUTM.transform(QgsPointXY(manouvre.DestPointX, manouvre.DestPointY))

                    if LastPoint != None:
                        SpeedMs = self.KtsToMs(manouvre.Speed)
                        dist = math.dist(LastPoint, UTMPoint)
                        timeToAdd = datetime.timedelta(seconds=round(dist / SpeedMs))
                        Direction = self.degToCompass(LastPointWGS84.azimuth(QgsPointXY(manouvre.DestPointX, manouvre.DestPointY)))
                        if manouvre.type == 'SK':
                            timeToAdd = timeToAdd + datetime.timedelta(seconds=manouvre.Duration)

                    else:
                        timeToAdd = datetime.timedelta(seconds=0)
                        Direction = 'N/A'
                        if manouvre.type == 'SK':
                            timeToAdd = timeToAdd + datetime.timedelta(seconds=manouvre.Duration)

                    TotalTime = TotalTime + timeToAdd
                    LastPoint = UTMPoint
                    LastPointWGS84 = QgsPointXY(manouvre.DestPointX, manouvre.DestPointY)

                    if id == Len_self_Mission_ListOfManouvres - 1:
                        self.EndPlanMarker.setCenter(MapPoint)

                    PlanPointsMapCRS.append(QgsPoint(MapPoint))

                    self.tableWidget.setItem(id,0, QTableWidgetItem(manouvre.Name))
                    self.tableWidget.setItem(id, 1, QTableWidgetItem(Direction))
                    self.tableWidget.setItem(id, 2, QTableWidgetItem(str(timeToAdd)))

                id = id+1

            self.EstDuration_label.setText('Est. duration: '+str(TotalTime))
            self.LinePlanRubber.setToGeometry(QgsGeometry.fromPolyline(PlanPointsMapCRS), None)
            try:
                self.tableWidget.itemChanged.connect(self.ChangeManouvreName)
            except:
                pass

    def ChangeManouvreName(self,item):
        futureselectedlist = []
        for id in self.selectedManouvres:
            futureselectedlist.append(id)
        if item.column() == 0:
            if item.text() != '':
                self.Mission.ListOfManouvres[item.row()].Name =  self.Mission.ListOfManouvres[item.row()].type + ' - ' + item.text()
                self.MissionToBeSaved = True
        self.ShowAllMissions()
        self.DisplayMission()
        self.DisplayManouvres()
        self.tableWidget.setSelectionMode(QtWidgets.QAbstractItemView.MultiSelection)
        for id in futureselectedlist:
            self.tableWidget.selectRow(id)
        self.tableWidget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)

    def GetSelectedManouvres(self):
        self.DeActivateAutoApplySettings()
        selection = (self.tableWidget.selectionModel().selectedRows())
        selectedList = []
        for i in selection:
            selectedList.append(i.row())
        if selectedList == []:
            self.scrollArea_5.setEnabled(False)
        else:
            self.scrollArea_5.setEnabled(True)

        self.selectedManouvres = selectedList
        self.DisplayManouvreSettings()
        self.DisplayManouvres()
        self.ActivateAutoApplySettings()

    def DisplayManouvres(self):
        if self.manouvreRbDict is not None:
            Id = 0
            for rubber in self.manouvreRbDict:
                self.canvas.scene().removeItem(self.manouvreRbDict[Id])
                Id = Id + 1

        self.manouvreRbDict = {}
        if self.Mission == None or self.Mission.ListOfManouvres != []:
            Id = 0
            for id in self.selectedManouvres:
                man = self.Mission.ListOfManouvres[id]
                if man.type == 'GoTo' or man.type == 'SK':
                    MapPoint = self.xformMapCrsToWGS84.transform(QgsPointXY(man.DestPointX, man.DestPointY),
                                                                 QgsCoordinateTransform.ReverseTransform)

                    self.manouvreRbDict[Id] = QgsVertexMarker(self.canvas)
                    self.manouvreRbDict[Id].setColor(QtGui.QColor(216, 27, 96))
                    self.manouvreRbDict[Id].setIconSize(20)
                    if man.type == 'GoTo':
                        self.manouvreRbDict[Id].setIconType(QgsVertexMarker.ICON_CROSS)  # or ICON_CROSS, ICON_X
                    else:
                        self.manouvreRbDict[Id].setIconType(QgsVertexMarker.ICON_CIRCLE)
                    self.manouvreRbDict[Id].setPenWidth(4)
                    self.manouvreRbDict[Id].setCenter(MapPoint)
                    Id = Id + 1


                if man.type == 'Rows' or man.type == 'Line' or man.type == 'LineWStops':
                    RowPoints = []
                    RunInRunOutPoints = []
                    for manouvre in man.ListOfGoTosOrCurves:
                        MapPoint = self.xformMapCrsToWGS84.transform(QgsPointXY(manouvre.DestPointX, manouvre.DestPointY),
                                                                     QgsCoordinateTransform.ReverseTransform)
                        RowPoints.append(QgsPoint(MapPoint))
                        if manouvre.type == 'GoTo' and manouvre.IsRunInRunOutPoint == True or manouvre.type == 'SK' :
                            RunInRunOutPoints.append(MapPoint)



                    if qgis.utils.Qgis.QGIS_VERSION.split('-')[0] >= '3.30.0':
                        self.manouvreRbDict[Id] = QgsRubberBand(self.canvas, QgsWkbTypes.GeometryType.Line)
                    else:
                        self.manouvreRbDict[Id] = QgsRubberBand(self.canvas, False)

                    self.manouvreRbDict[Id].setColor(QtGui.QColor(216, 27, 96))
                    self.manouvreRbDict[Id].setWidth(6)
                    self.manouvreRbDict[Id].setLineStyle(Qt.PenStyle(Qt.DotLine))
                    self.manouvreRbDict[Id].setToGeometry(QgsGeometry.fromPolyline(RowPoints), None)
                    Id = Id + 1

                    if RunInRunOutPoints != []:
                        for point in RunInRunOutPoints:
                            self.manouvreRbDict[Id] = QgsVertexMarker(self.canvas)
                            self.manouvreRbDict[Id].setColor(QtGui.QColor(102, 255, 0))
                            self.manouvreRbDict[Id].setIconSize(15)
                            self.manouvreRbDict[Id].setIconType(QgsVertexMarker.ICON_CIRCLE)  # or ICON_CROSS, ICON_X
                            self.manouvreRbDict[Id].setPenWidth(2)
                            self.manouvreRbDict[Id].setCenter(point)
                            Id = Id + 1

    def DisplayManouvreSettings(self):
        if self.selectedManouvres != [] and self.Mission.ListOfManouvres != []:
            Manouvre = self.Mission.ListOfManouvres[self.selectedManouvres[0]]
            self.PlanSpeed_doubleSpinBox_2.setValue(Manouvre.Speed)
            if Manouvre.type == 'SK' or Manouvre.type == 'LineWStops':
                self.StationKeepingDuration_spinBox_2.setValue(Manouvre.Duration)
                self.StationKeepingDuration_spinBox_2.setEnabled(True)
            else:
                self.StationKeepingDuration_spinBox_2.setEnabled(False)
            self.PlanHeight_doubleSpinBox_2.setValue(Manouvre.Height[0])
            self.PlanHeight_comboBox_2.setCurrentIndex(Manouvre.Height[1])
            self.Acoms_AutoSend_checkBox_2.setChecked(Manouvre.Acoms.Active)
            self.Acoms_Interval_spinBox_2.setValue(Manouvre.Acoms.Interval)
            self.Acoms_CurveOnly_checkBox_2.setChecked(Manouvre.Acoms.InCurveOnly)
            self.Acoms_Repetitions_spinBox_2.setValue(Manouvre.Acoms.Repetitions)
            self.MBES_Active_checkBox_2.setChecked(Manouvre.MBES.Active)
            self.MBES_GateMode_comboBox_2.setCurrentIndex(Manouvre.MBES.GateMode)
            self.MBES_OnLinesOnly_checkBox_2.setChecked(Manouvre.MBES.OnLinesOnly)
            self.MBES_UpperGate_spinBox_2.setValue(Manouvre.MBES.UpGate)
            self.MBES_Angle_spinBox_2.setValue(Manouvre.MBES.Angle)
            self.MBES_LowerGate_spinBox_2.setValue(Manouvre.MBES.LowGate)
            self.MBES_OpMode_comboBox_2.setCurrentIndex(Manouvre.MBES.OpMode)
            self.MBES_BeamDistrib_comboBox_2.setCurrentIndex(Manouvre.MBES.BeamDistribution)
            self.MBES_BeamNumber_comboBox_2.setCurrentIndex(Manouvre.MBES.BeamNumber)
            self.MBES_TxFrequency_spinBox_2.setValue(Manouvre.MBES.TxFrequency)
            self.MBES_TxBandwith_spinBox_2.setValue(Manouvre.MBES.TxBandwith)
            self.MBES_TxAmplitude_spinBox_2.setValue(Manouvre.MBES.TxAmplitude)
            self.MBES_TxSweeplenght_spinBox_2.setValue(Manouvre.MBES.TxSweepLenght)
            self.MBES_Matchfilter_comboBox_2.setCurrentIndex(Manouvre.MBES.TxMatchFilter)
            self.SSS_Active_checkBox_2.setChecked(Manouvre.SSS.Active)
            self.SSS_Gain_comboBox_2.setCurrentIndex(Manouvre.SSS.Gain)
            self.SSS_OnLinesOnly_checkBox_2.setChecked(Manouvre.SSS.OnLinesOnly)
            self.SSS_OpMode_comboBox_2.setCurrentIndex(Manouvre.SSS.OpMode)
            self.SSS_Range_spinBox_2.setValue(Manouvre.SSS.Range)
            self.SBP_Active_checkBox_2.setChecked(Manouvre.SBP.Active)
            self.SBP_Range_spinBox_2.setValue(Manouvre.SBP.Range)
            self.SBP_OnLinesOnly_checkBox_2.setChecked(Manouvre.SBP.OnLinesOnly)
            self.HFGain_spinBox_2.setValue(Manouvre.SBP.HFGain)
            self.LFGain_spinBox_2.setValue(Manouvre.SBP.LFGain)
            self.HFTreshold_spinBox_2.setValue(Manouvre.SBP.HFTreshold)
            self.LFTreshold_spinBox_2.setValue(Manouvre.SBP.LFTreshold)
            self.HFContrast_spinBox_2.setValue(Manouvre.SBP.HFContrast)
            self.LFContrast_spinBox_2.setValue(Manouvre.SBP.LFContrast)
            self.CAM_Active_checkBox_2.setChecked(Manouvre.Camera.Active)
            self.CAM_ShowVideo_comboBox_2.setCurrentIndex(Manouvre.Camera.ShowVideo)
            self.CAM_Fps_spinBox_2.setValue(Manouvre.Camera.Framerate)
            self.CAM_ImgCompression_comboBox_2.setCurrentIndex(Manouvre.Camera.Compression)
            self.CAM_Gain_spinBox_2.setValue(Manouvre.Camera.Gain)
            self.CAM_ShutterTime_spinBox_2.setValue(Manouvre.Camera.ShutterTime)
            self.CAM_Format_comboBox_2.setCurrentIndex(Manouvre.Camera.Format)
            self.CAM_Strobe_comboBox_2.setCurrentIndex(Manouvre.Camera.Strobe)
            self.CAM_StrobeIntensity_spinBox_2.setValue(Manouvre.Camera.StrobeIntensity)
            self.CAM_OnLinesOnly_checkBox_2.setChecked(Manouvre.Camera.OnLinesOnly)
            self.OAS_Active_checkBox_2.setChecked(Manouvre.OAS.Active)
            self.MAG_Active_checkBox_2.setChecked(Manouvre.Mag.Active)
            self.MAG_OnLinesOnly_checkBox_2.setChecked(Manouvre.Mag.OnLinesOnly)
            self.PB_Active_checkBox_2.setChecked(Manouvre.PlanBlue.Active)
            self.PB_OnLinesOnly_checkBox_2.setChecked(Manouvre.PlanBlue.OnLinesOnly)

            if self.MBES_Active_checkBox_2.isChecked() == True:
                self.MBES_toolButton.setStyleSheet("background-color:green")
            else:
                self.MBES_toolButton.setStyleSheet("background-color:red")

            if self.SSS_Active_checkBox_2.isChecked() == True:
                self.SSS_toolButton.setStyleSheet("background-color:green")
            else:
                self.SSS_toolButton.setStyleSheet("background-color:red")

            if self.SBP_Active_checkBox_2.isChecked() == True:
                self.SBP_toolButton.setStyleSheet("background-color:green")
            else:
                self.SBP_toolButton.setStyleSheet("background-color:red")

            if self.MAG_Active_checkBox_2.isChecked() == True:
                self.MAG_toolButton.setStyleSheet("background-color:green")
            else:
                self.MAG_toolButton.setStyleSheet("background-color:red")

            if self.PB_Active_checkBox_2.isChecked() == True:
                self.PB_toolButton.setStyleSheet("background-color:green")
            else:
                self.PB_toolButton.setStyleSheet("background-color:red")

            if self.Acoms_AutoSend_checkBox_2.isChecked() == True:
                self.ACOMS_toolButton.setStyleSheet("background-color:green")
            else:
                self.ACOMS_toolButton.setStyleSheet("background-color:red")

            if self.OAS_Active_checkBox_2.isChecked() == True:
                self.OAS_toolButton.setStyleSheet("background-color:green")
            else:
                self.OAS_toolButton.setStyleSheet("background-color:red")

            if self.CAM_Active_checkBox_2.isChecked() == True:
                self.CAM_toolButton.setStyleSheet("background-color:green")
            else:
                self.CAM_toolButton.setStyleSheet("background-color:red")


        else:
            self.MBES_toolButton.setStyleSheet("")
            self.SBP_toolButton.setStyleSheet("")
            self.SSS_toolButton.setStyleSheet("")
            self.MAG_toolButton.setStyleSheet("")
            self.PB_toolButton.setStyleSheet("")
            self.OAS_toolButton.setStyleSheet("")
            self.CAM_toolButton.setStyleSheet("")
            self.ACOMS_toolButton.setStyleSheet("")

    def ChangeManouvreSettings(self):
        if self.selectedManouvres != []:
            senderName = self.sender().objectName()

            futureselectedlist = []
            for id in self.selectedManouvres:
                futureselectedlist.append(id)

            if senderName == "CopySettings_pushButton":

                ManouvreAcoms = Acoms(self.Acoms_AutoSend_checkBox_2.isChecked(),
                                   self.Acoms_Interval_spinBox_2.value(),
                                   self.Acoms_Repetitions_spinBox_2.value(),
                                   self.Acoms_CurveOnly_checkBox_2.isChecked())

                ManouvreMBES = MBES(self.MBES_Active_checkBox_2.isChecked(),
                                    self.MBES_OnLinesOnly_checkBox_2.isChecked(),
                                    self.MBES_Angle_spinBox_2.value(),
                                    self.MBES_OpMode_comboBox_2.currentIndex(),
                                    self.MBES_GateMode_comboBox_2.currentIndex(),
                                    self.MBES_UpperGate_spinBox_2.value(),
                                    self.MBES_LowerGate_spinBox_2.value(),
                                    self.MBES_BeamDistrib_comboBox_2.currentIndex(),
                                    self.MBES_TxFrequency_spinBox_2.value(),
                                    self.MBES_TxBandwith_spinBox_2.value(),
                                    self.MBES_TxAmplitude_spinBox_2.value(),
                                    self.MBES_TxSweeplenght_spinBox_2.value(),
                                    self.MBES_Matchfilter_comboBox_2.currentIndex(),
                                    self.MBES_BeamNumber_comboBox_2.currentIndex())

                ManouvreSSS = SSS(self.SSS_Active_checkBox_2.isChecked(),
                               self.SSS_OnLinesOnly_checkBox_2.isChecked(),
                               self.SSS_Range_spinBox_2.value(),
                               self.SSS_OpMode_comboBox_2.currentIndex(),
                               self.SSS_Gain_comboBox_2.currentIndex())

                ManouvreSBP = SBP(self.SBP_Active_checkBox_2.isChecked(),
                               self.SBP_OnLinesOnly_checkBox_2.isChecked(),
                               self.SBP_Range_spinBox_2.value(),
                               self.LFGain_spinBox_2.value(),
                               self.LFTreshold_spinBox_2.value(),
                               self.LFContrast_spinBox_2.value(),
                               self.HFGain_spinBox_2.value(),
                               self.HFTreshold_spinBox_2.value(),
                               self.HFContrast_spinBox_2.value())

                ManouvreCamera = Camera(self.CAM_Active_checkBox_2.isChecked(),
                                     self.CAM_Fps_spinBox_2.value(),
                                     self.CAM_ShowVideo_comboBox_2.currentIndex(),
                                     self.CAM_Gain_spinBox_2.value(),
                                     self.CAM_Format_comboBox_2.currentIndex(),
                                     self.CAM_ImgCompression_comboBox_2.currentIndex(),
                                     self.CAM_ShutterTime_spinBox_2.value(),
                                     self.CAM_Strobe_comboBox_2.currentIndex(),
                                     self.CAM_StrobeIntensity_spinBox_2.value(),
                                     self.CAM_OnLinesOnly_checkBox_2.isChecked())


                ManouvreMAG = MAG(self.MAG_Active_checkBox_2.isChecked(),self.MAG_OnLinesOnly_checkBox_2.isChecked())

                ManouvrePB = PlanBlue(self.PB_Active_checkBox_2.isChecked(), self.PB_OnLinesOnly_checkBox_2.isChecked())

                ManouvreOAS = OAS(self.OAS_Active_checkBox_2.isChecked())

                for id in self.selectedManouvres:
                    Manouvre = self.Mission.ListOfManouvres[id]
                    if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                        Manouvre.Speed = self.PlanSpeed_doubleSpinBox_2.value()
                        if Manouvre.type == 'SK':
                            Manouvre.Duration = self.StationKeepingDuration_spinBox_2.value()
                        Manouvre.Height = (self.PlanHeight_doubleSpinBox_2.value(),self.PlanHeight_comboBox_2.currentIndex())
                        Manouvre.MBES = ManouvreMBES
                        Manouvre.SSS = ManouvreSSS
                        Manouvre.SBP = ManouvreSBP
                        Manouvre.Acoms = ManouvreAcoms
                        Manouvre.Camera = ManouvreCamera
                        Manouvre.OAS = ManouvreOAS
                        Manouvre.Mag = ManouvreMAG
                        Manouvre.PlanBlue = ManouvrePB
                    if Manouvre.type == 'Rows' or Manouvre.type == 'Line' or Manouvre.type == 'LineWStops':
                        if Manouvre.type =='LineWStops':
                            Manouvre.Duration = self.StationKeepingDuration_spinBox_2.value()
                        Manouvre.Speed = self.PlanSpeed_doubleSpinBox_2.value()
                        Manouvre.Height = (self.PlanHeight_doubleSpinBox_2.value(), self.PlanHeight_comboBox_2.currentIndex())
                        Manouvre.MBES = ManouvreMBES
                        Manouvre.SSS = ManouvreSSS
                        Manouvre.SBP = ManouvreSBP
                        Manouvre.Acoms = ManouvreAcoms
                        Manouvre.Camera = ManouvreCamera
                        Manouvre.OAS = ManouvreOAS
                        Manouvre.Mag = ManouvreMAG
                        Manouvre.PlanBlue = ManouvrePB
                        for man in Manouvre.ListOfGoTosOrCurves:
                            man.Speed = self.PlanSpeed_doubleSpinBox_2.value()
                            if man.type == 'SK':
                                man.Duration = self.StationKeepingDuration_spinBox_2.value()
                            else:
                                man.Height = (self.PlanHeight_doubleSpinBox_2.value(), self.PlanHeight_comboBox_2.currentIndex())
                            man.MBES = ManouvreMBES
                            man.SSS = ManouvreSSS
                            man.SBP = ManouvreSBP
                            man.Acoms = ManouvreAcoms
                            man.Camera = ManouvreCamera
                            man.OAS = ManouvreOAS
                            man.Mag = ManouvreMAG
                            man.PlanBlue = ManouvrePB

            elif senderName == "PlanSpeed_doubleSpinBox_2":
                for id in self.selectedManouvres:
                    Manouvre = self.Mission.ListOfManouvres[id]
                    if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                        Manouvre.Speed = self.PlanSpeed_doubleSpinBox_2.value()
                    if Manouvre.type == 'Rows' or Manouvre.type == 'Line' or Manouvre.type == 'LineWStops':
                        Manouvre.Speed = self.PlanSpeed_doubleSpinBox_2.value()
                        for man in Manouvre.ListOfGoTosOrCurves:
                            man.Speed = self.PlanSpeed_doubleSpinBox_2.value()

            elif senderName == "PlanHeight_doubleSpinBox_2" or senderName == "PlanHeight_comboBox_2":
                for id in self.selectedManouvres:
                    Manouvre = self.Mission.ListOfManouvres[id]
                    if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                        Manouvre.Height = (self.PlanHeight_doubleSpinBox_2.value(),self.PlanHeight_comboBox_2.currentIndex())
                    if Manouvre.type == 'Rows' or Manouvre.type == 'Line' or Manouvre.type == 'LineWStops':
                        Manouvre.Height = (self.PlanHeight_doubleSpinBox_2.value(), self.PlanHeight_comboBox_2.currentIndex())
                        for man in Manouvre.ListOfGoTosOrCurves:
                            if man.type != 'SK':
                                man.Height = (self.PlanHeight_doubleSpinBox_2.value(), self.PlanHeight_comboBox_2.currentIndex())

            elif senderName == "Acoms_AutoSend_checkBox_2" or \
                    senderName == "Acoms_Interval_spinBox_2" or \
                    senderName == "Acoms_CurveOnly_checkBox_2" or \
                    senderName == "Acoms_Repetitions_spinBox_2":

                ManouvreAcoms = Acoms(self.Acoms_AutoSend_checkBox_2.isChecked(),
                                      self.Acoms_Interval_spinBox_2.value(),
                                      self.Acoms_Repetitions_spinBox_2.value(),
                                      self.Acoms_CurveOnly_checkBox_2.isChecked())

                for id in self.selectedManouvres:
                    Manouvre = self.Mission.ListOfManouvres[id]
                    if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                        Manouvre.Acoms = ManouvreAcoms
                    if Manouvre.type == 'Rows' or Manouvre.type == 'Line' or Manouvre.type == 'LineWStops':
                        Manouvre.Acoms = ManouvreAcoms
                        for man in Manouvre.ListOfGoTosOrCurves:
                            man.Acoms = ManouvreAcoms

            elif senderName == "StationKeepingDuration_spinBox_2":
                for id in self.selectedManouvres:
                    Manouvre = self.Mission.ListOfManouvres[id]
                    if Manouvre.type == 'SK':
                        Manouvre.Duration = self.StationKeepingDuration_spinBox_2.value()
                    if Manouvre.type == 'LineWStops':
                        Manouvre.Duration = self.StationKeepingDuration_spinBox_2.value()
                        for man in Manouvre.ListOfGoTosOrCurves:
                            if man.type == 'SK':
                                man.Duration = self.StationKeepingDuration_spinBox_2.value()


            if senderName == "MBES_Active_checkBox_2" or \
                    senderName == "MBES_GateMode_comboBox_2" or \
                    senderName == "MBES_OnLinesOnly_checkBox_2" or \
                    senderName == "MBES_UpperGate_spinBox_2" or \
                    senderName == "MBES_LowerGate_spinBox_2" or \
                    senderName == "MBES_OpMode_comboBox_2" or \
                    senderName == "MBES_Angle_spinBox_2" or \
                    senderName == "MBES_BeamDistrib_comboBox_2" or \
                    senderName == "MBES_BeamNumber_comboBox_2" or \
                    senderName == "MBES_TxFrequency_spinBox_2" or \
                    senderName == "MBES_TxAmplitude_spinBox_2" or \
                    senderName == "MBES_Matchfilter_comboBox_2" or \
                    senderName == "MBES_TxBandwith_spinBox_2" or \
                    senderName == "MBES_TxSweeplenght_spinBox_2":


                ManouvreMBES = MBES(self.MBES_Active_checkBox_2.isChecked(),
                                    self.MBES_OnLinesOnly_checkBox_2.isChecked(),
                                    self.MBES_Angle_spinBox_2.value(),
                                    self.MBES_OpMode_comboBox_2.currentIndex(),
                                    self.MBES_GateMode_comboBox_2.currentIndex(),
                                    self.MBES_UpperGate_spinBox_2.value(),
                                    self.MBES_LowerGate_spinBox_2.value(),
                                    self.MBES_BeamDistrib_comboBox_2.currentIndex(),
                                    self.MBES_TxFrequency_spinBox_2.value(),
                                    self.MBES_TxBandwith_spinBox_2.value(),
                                    self.MBES_TxAmplitude_spinBox_2.value(),
                                    self.MBES_TxSweeplenght_spinBox_2.value(),
                                    self.MBES_Matchfilter_comboBox_2.currentIndex(),
                                    self.MBES_BeamNumber_comboBox_2.currentIndex())

                for id in self.selectedManouvres:
                    Manouvre = self.Mission.ListOfManouvres[id]
                    if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                        Manouvre.MBES = ManouvreMBES
                    if Manouvre.type == 'Rows' or Manouvre.type == 'Line' or Manouvre.type == 'LineWStops':
                        Manouvre.MBES = ManouvreMBES
                        for man in Manouvre.ListOfGoTosOrCurves:
                            man.MBES = ManouvreMBES

            elif senderName == "SSS_Active_checkBox_2" or \
                    senderName == "SSS_Gain_comboBox_2" or \
                    senderName == "SSS_OnLinesOnly_checkBox_2" or \
                    senderName == "SSS_Range_spinBox_2" or \
                    senderName == "SSS_OpMode_comboBox_2":

                ManouvreSSS = SSS(self.SSS_Active_checkBox_2.isChecked(),
                                  self.SSS_OnLinesOnly_checkBox_2.isChecked(),
                                  self.SSS_Range_spinBox_2.value(),
                                  self.SSS_OpMode_comboBox_2.currentIndex(),
                                  self.SSS_Gain_comboBox_2.currentIndex())

                for id in self.selectedManouvres:
                    Manouvre = self.Mission.ListOfManouvres[id]
                    if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                        Manouvre.SSS = ManouvreSSS
                    if Manouvre.type == 'Rows' or Manouvre.type == 'Line' or Manouvre.type == 'LineWStops':
                        Manouvre.SSS = ManouvreSSS
                        for man in Manouvre.ListOfGoTosOrCurves:
                            man.SSS = ManouvreSSS

            elif senderName == "SBP_Active_checkBox_2" or \
                    senderName == "SBP_Range_spinBox_2" or \
                    senderName == "SBP_OnLinesOnly_checkBox_2" or \
                    senderName == "HFGain_spinBox_2" or \
                    senderName == "LFGain_spinBox_2" or \
                    senderName == "LFTreshold_spinBox_2" or \
                    senderName == "HFTreshold_spinBox_2" or \
                    senderName == "LFContrast_spinBox_2" or \
                    senderName == "HFContrast_spinBox_2":

                ManouvreSBP = SBP(self.SBP_Active_checkBox_2.isChecked(),
                                  self.SBP_OnLinesOnly_checkBox_2.isChecked(),
                                  self.SBP_Range_spinBox_2.value(),
                                  self.LFGain_spinBox_2.value(),
                                  self.LFTreshold_spinBox_2.value(),
                                  self.LFContrast_spinBox_2.value(),
                                  self.HFGain_spinBox_2.value(),
                                  self.HFTreshold_spinBox_2.value(),
                                  self.HFContrast_spinBox_2.value())

                for id in self.selectedManouvres:
                    Manouvre = self.Mission.ListOfManouvres[id]
                    if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                        Manouvre.SBP = ManouvreSBP
                    if Manouvre.type == 'Rows' or Manouvre.type == 'Line' or Manouvre.type == 'LineWStops':
                        Manouvre.SBP = ManouvreSBP
                        for man in Manouvre.ListOfGoTosOrCurves:
                            man.SBP = ManouvreSBP

            elif senderName == "CAM_Active_checkBox_2" or \
                    senderName == "CAM_OnLinesOnly_checkBox_2" or \
                    senderName == "CAM_Fps_spinBox_2" or \
                    senderName == "CAM_ShowVideo_comboBox_2" or \
                    senderName == "CAM_Gain_spinBox_2" or \
                    senderName == "CAM_ImgCompression_comboBox_2" or \
                    senderName == "CAM_Format_comboBox_2" or \
                    senderName == "CAM_ShutterTime_spinBox_2" or \
                    senderName == "CAM_StrobeIntensity_spinBox_2" or \
                    senderName == "CAM_Strobe_comboBox_2":

                ManouvreCamera = Camera(self.CAM_Active_checkBox_2.isChecked(),
                                        self.CAM_Fps_spinBox_2.value(),
                                        self.CAM_ShowVideo_comboBox_2.currentIndex(),
                                        self.CAM_Gain_spinBox_2.value(),
                                        self.CAM_Format_comboBox_2.currentIndex(),
                                        self.CAM_ImgCompression_comboBox_2.currentIndex(),
                                        self.CAM_ShutterTime_spinBox_2.value(),
                                        self.CAM_Strobe_comboBox_2.currentIndex(),
                                        self.CAM_StrobeIntensity_spinBox_2.value(),
                                        self.CAM_OnLinesOnly_checkBox_2.isChecked())

                for id in self.selectedManouvres:
                    Manouvre = self.Mission.ListOfManouvres[id]
                    if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                        Manouvre.Camera = ManouvreCamera
                    if Manouvre.type == 'Rows' or Manouvre.type == 'Line' or Manouvre.type == 'LineWStops':
                        Manouvre.Camera = ManouvreCamera
                        for man in Manouvre.ListOfGoTosOrCurves:
                            man.Camera = ManouvreCamera

            elif senderName == "OAS_Active_checkBox_2":
                ManouvreOAS = OAS(self.OAS_Active_checkBox_2.isChecked())

                for id in self.selectedManouvres:
                    Manouvre = self.Mission.ListOfManouvres[id]
                    if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                        Manouvre.OAS = ManouvreOAS
                    if Manouvre.type == 'Rows' or Manouvre.type == 'Line':
                        Manouvre.OAS = ManouvreOAS
                        for man in Manouvre.ListOfGoTosOrCurves:
                            man.OAS = ManouvreOAS

            elif senderName == "MAG_Active_checkBox_2"or senderName == "MAG_OnLinesOnly_checkBox_2":
                ManouvreMAG = MAG(self.MAG_Active_checkBox_2.isChecked(), self.MAG_OnLinesOnly_checkBox_2.isChecked())

                for id in self.selectedManouvres:
                    Manouvre = self.Mission.ListOfManouvres[id]
                    if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                        Manouvre.Mag = ManouvreMAG
                    if Manouvre.type == 'Rows' or Manouvre.type == 'Line' or Manouvre.type == 'LineWStops':
                        Manouvre.Mag = ManouvreMAG
                        for man in Manouvre.ListOfGoTosOrCurves:
                            man.Mag = ManouvreMAG

            elif senderName == "PB_Active_checkBox_2" or senderName == "PB_OnLinesOnly_checkBox_2":
                ManouvrePB = PlanBlue(self.PB_Active_checkBox_2.isChecked(), self.PB_OnLinesOnly_checkBox_2.isChecked())

                for id in self.selectedManouvres:
                    Manouvre = self.Mission.ListOfManouvres[id]
                    if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                        Manouvre.PlanBlue = ManouvrePB
                    if Manouvre.type == 'Rows' or Manouvre.type == 'Line' or Manouvre.type == 'LineWStops':
                        Manouvre.PlanBlue = ManouvrePB
                        for man in Manouvre.ListOfGoTosOrCurves:
                            man.PlanBlue = ManouvrePB

            self.MissionToBeSaved = True
            self.ShowAllMissions()
            self.DisplayMission()
            self.DisplayManouvres()
            self.tableWidget.setSelectionMode(QtWidgets.QAbstractItemView.MultiSelection)
            for id in futureselectedlist:
                self.tableWidget.selectRow(id)
            self.tableWidget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)

    def ActivateMBES(self):
        if self.MBES_toolButton.styleSheet() == "background-color:red":
            self.MBES_toolButton.setStyleSheet("background-color:green")
            self.MBES_Active_checkBox_2.setChecked(True)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True
        elif self.MBES_toolButton.styleSheet() == "background-color:green":
            self.MBES_toolButton.setStyleSheet("background-color:red")
            self.MBES_Active_checkBox_2.setChecked(False)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True

    def ActivateSSS(self):
        if self.SSS_toolButton.styleSheet() == "background-color:red":
            self.SSS_toolButton.setStyleSheet("background-color:green")
            self.SSS_Active_checkBox_2.setChecked(True)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True
        elif self.SSS_toolButton.styleSheet() == "background-color:green":
            self.SSS_toolButton.setStyleSheet("background-color:red")
            self.SSS_Active_checkBox_2.setChecked(False)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True

    def ActivateMAG(self):
        if self.MAG_toolButton.styleSheet() == "background-color:red":
            self.MAG_toolButton.setStyleSheet("background-color:green")
            self.MAG_Active_checkBox_2.setChecked(True)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True
        elif self.MAG_toolButton.styleSheet() == "background-color:green":
            self.MAG_toolButton.setStyleSheet("background-color:red")
            self.MAG_Active_checkBox_2.setChecked(False)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True

    def ActivatePB(self):
        if self.PB_toolButton.styleSheet() == "background-color:red":
            self.PB_toolButton.setStyleSheet("background-color:green")
            self.PB_Active_checkBox_2.setChecked(True)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True
        elif self.PB_toolButton.styleSheet() == "background-color:green":
            self.PB_toolButton.setStyleSheet("background-color:red")
            self.PB_Active_checkBox_2.setChecked(False)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True

    def ActivateSBP(self):
        if self.SBP_toolButton.styleSheet() == "background-color:red":
            self.SBP_toolButton.setStyleSheet("background-color:green")
            self.SBP_Active_checkBox_2.setChecked(True)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True
        elif self.SBP_toolButton.styleSheet() == "background-color:green":
            self.SBP_toolButton.setStyleSheet("background-color:red")
            self.SBP_Active_checkBox_2.setChecked(False)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True

    def ActivateCAM(self):
        if self.CAM_toolButton.styleSheet() == "background-color:red":
            self.CAM_toolButton.setStyleSheet("background-color:green")
            self.CAM_Active_checkBox_2.setChecked(True)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True
        elif self.CAM_toolButton.styleSheet() == "background-color:green":
            self.CAM_toolButton.setStyleSheet("background-color:red")
            self.CAM_Active_checkBox_2.setChecked(False)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True

    def ActivateACOMS(self):
        if self.ACOMS_toolButton.styleSheet() == "background-color:red":
            self.ACOMS_toolButton.setStyleSheet("background-color:green")
            self.Acoms_AutoSend_checkBox_2.setChecked(True)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True
        elif self.ACOMS_toolButton.styleSheet() == "background-color:green":
            self.ACOMS_toolButton.setStyleSheet("background-color:red")
            self.Acoms_AutoSend_checkBox_2.setChecked(False)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True

    def ActivateOAS(self):
        if self.OAS_toolButton.styleSheet() == "background-color:red":
            self.OAS_toolButton.setStyleSheet("background-color:green")
            self.OAS_Active_checkBox_2.setChecked(True)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True
        elif self.OAS_toolButton.styleSheet() == "background-color:green":
            self.OAS_toolButton.setStyleSheet("background-color:red")
            self.OAS_Active_checkBox_2.setChecked(False)
            self.ChangeManouvreSettings()
            self.MissionToBeSaved = True

    def ReverseManouvre(self):
        futureselectedlist = []
        for id in self.selectedManouvres:
                futureselectedlist.append(id)

        for id in self.selectedManouvres:
            manouvre = self.Mission.ListOfManouvres[id]
            if manouvre.type == 'Line':
                manouvre.ListOfGoTosOrCurves[0].InCurve = False
                manouvre.ListOfGoTosOrCurves[-1].InCurve = True
                manouvre.ListOfGoTosOrCurves.reverse()
                self.MissionToBeSaved = True
            if manouvre.type == 'Rows' or manouvre.type == 'LineWStops':
                straight = manouvre.ListOfGoTosOrCurves
                reverse = manouvre.InverseListOfGotosOrCurves
                manouvre.ListOfGoTosOrCurves = reverse
                manouvre.InverseListOfGotosOrCurves = straight
                self.MissionToBeSaved = True

        self.ShowAllMissions()
        self.DisplayMission()
        self.DisplayManouvres()

        self.tableWidget.setSelectionMode(QtWidgets.QAbstractItemView.MultiSelection)
        for id in futureselectedlist:
            self.tableWidget.selectRow(id)
        self.tableWidget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)

    def ReverseMission(self):
        if self.Mission is not None:
            self.Mission.ListOfManouvres.reverse()
            for manouvre in self.Mission.ListOfManouvres:
                if manouvre.type == 'Line':
                    manouvre.ListOfGoTosOrCurves[0].InCurve = False
                    manouvre.ListOfGoTosOrCurves[-1].InCurve = True
                    manouvre.ListOfGoTosOrCurves.reverse()
                if manouvre.type == 'Rows' or manouvre.type == 'LineWStops':
                    straight = manouvre.ListOfGoTosOrCurves
                    reverse = manouvre.InverseListOfGotosOrCurves
                    manouvre.ListOfGoTosOrCurves = reverse
                    manouvre.InverseListOfGotosOrCurves = straight
            self.MissionToBeSaved = True
            self.ShowAllMissions()
            self.DisplayMission()

    def Delete(self):
        if self.selectedManouvres != []:
            if self.Mission is not None:
                if self.Mission.ListOfManouvres != []:
                    if self.selectedManouvres != []:
                        lastSelected = min(self.selectedManouvres)-1
                        if lastSelected < 0:
                            lastSelected = 0
                    for index in sorted(self.selectedManouvres, reverse=True):
                        del self.Mission.ListOfManouvres[index]
                        self.MissionToBeSaved = True
                    self.ShowAllMissions()
                    self.DisplayMission()
                    self.DisplayManouvres()
                    if self.Mission.ListOfManouvres != []:
                        self.tableWidget.selectRow(lastSelected)

    def MoveUp(self):
        futureselectedlist = []
        for id in self.selectedManouvres:
            if id > 0:
                futureselectedlist.append(id-1)
            else:
                futureselectedlist.append(id)

        for id in self.selectedManouvres:
            if id > 0:
                self.Mission.ListOfManouvres.insert(id-1, self.Mission.ListOfManouvres.pop(id))
                self.MissionToBeSaved = True
        self.ShowAllMissions()
        self.DisplayMission()
        self.DisplayManouvres()
        self.tableWidget.setSelectionMode(QtWidgets.QAbstractItemView.MultiSelection)
        for id in futureselectedlist:
            self.tableWidget.selectRow(id)
        self.tableWidget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)

    def MoveDown(self):
        futureselectedlist = []
        for id in self.selectedManouvres:
            if id < len(self.Mission.ListOfManouvres)-1:
                futureselectedlist.append(id + 1)
            else:
                futureselectedlist.append(id)

        for id in self.selectedManouvres:
            if id < len(self.Mission.ListOfManouvres)-1:
                self.Mission.ListOfManouvres.insert(id+1, self.Mission.ListOfManouvres.pop(id))
                self.MissionToBeSaved = True
        self.ShowAllMissions()
        self.DisplayMission()
        self.DisplayManouvres()

        self.tableWidget.setSelectionMode(QtWidgets.QAbstractItemView.MultiSelection)
        for id in futureselectedlist:
            self.tableWidget.selectRow(id)
        self.tableWidget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)

    def AddLine(self,SurfaceStops):
        if self.Mission is not None:
            layer = self.iface.activeLayer()
            if layer:
                if type(layer).__name__ == "QgsVectorLayer":
                    selection = layer.selectedFeatures()
                    if selection != []:
                        self.RetrieveManouvresSettings()
                        LayerEPSG = layer.crs().authid()
                        crsOrig = QgsCoordinateReferenceSystem(LayerEPSG)
                        crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
                        transformContext = QgsProject.instance().transformContext()
                        xformLayerToWGS84 = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                        for feat in selection:
                            geom = feat.geometry()
                            geomSingleType = QgsWkbTypes.isSingleType(geom.wkbType())
                            if geom.type() == QgsWkbTypes.LineGeometry:
                                name = 'Line'
                                layerFields = layer.fields().names()
                                id = 0
                                for field in layerFields:
                                    if field.lower().find('name') != -1:
                                        attr = feat.attributes()[id]
                                        name = 'Line - ' +str(attr)
                                        break
                                    else:
                                        id = id +1
                                Ln = Line([],self.PlanSpeed,self.MBES,self.SSS,self.SBP,self.MAG,self.PB,self.Camera,self.OAS,self.PlanHeight,self.Acoms,name)
                                if geomSingleType:
                                    x = geom.asPolyline()
                                    LineList = []
                                    i = 0
                                    for p in x:
                                        if i == 0:
                                            point = xformLayerToWGS84.transform(p)
                                            UTMEPSG = self.get_utm_zoneEPSG(point.x(),point.y())
                                            crsDest = QgsCoordinateReferenceSystem(UTMEPSG)
                                            crsOrig  = QgsCoordinateReferenceSystem(LayerEPSG)
                                            xformLayerToUTM = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                                            crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
                                            crsOrig  = QgsCoordinateReferenceSystem(UTMEPSG)
                                            xformUTMToWGS84 = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                                        point = xformLayerToUTM.transform(p)
                                        LineList.append(point)
                                        i = i + 1
                                else:
                                    x = geom.asMultiPolyline()
                                    i = 0
                                    LineList = []
                                    for line in x:
                                        for p in line:
                                            if i == 0:
                                                point = xformLayerToWGS84.transform(p)
                                                UTMEPSG = self.get_utm_zoneEPSG(point.x(), point.y())
                                                crsDest = QgsCoordinateReferenceSystem(UTMEPSG)
                                                crsOrig = QgsCoordinateReferenceSystem(LayerEPSG)
                                                xformLayerToUTM = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                                                crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
                                                crsOrig = QgsCoordinateReferenceSystem(UTMEPSG)
                                                xformUTMToWGS84 = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                                            point = xformLayerToUTM.transform(p)
                                            LineList.append(point)
                                            i = i+1

                                densifiedLine = self.densify_geometry(numpy.array(LineString(LineList).coords),self.MaxDistance).tolist()
                                UTMRunInBearing = 90 - math.degrees(
                                    math.atan2((densifiedLine[0][1] - densifiedLine[1][1]),
                                               (densifiedLine[0][0] - densifiedLine[1][0])))
                                if UTMRunInBearing < 0.0:
                                    UTMRunInBearing += 360.0
                                UTMRunOutBearing = 90 - math.degrees(
                                    math.atan2((densifiedLine[-1][1] - densifiedLine[-2][1]),
                                               (densifiedLine[-1][0] - densifiedLine[-2][0])))
                                if UTMRunOutBearing < 0.0:
                                    UTMRunOutBearing += 360.0

                                UTMRunInBearing = math.radians(UTMRunInBearing)
                                UTMRunOutBearing = math.radians(UTMRunOutBearing)

                                RunInPointX = densifiedLine[0][0] + (self.RunInRunOut * math.sin(UTMRunInBearing))
                                RunInPointY = densifiedLine[0][1] + (self.RunInRunOut * math.cos(UTMRunInBearing))
                                RunOutPointX = densifiedLine[-1][0] + (self.RunInRunOut * math.sin(UTMRunOutBearing))
                                RunOutPointY = densifiedLine[-1][1] + (self.RunInRunOut * math.cos(UTMRunOutBearing))
                                densifiedLine.insert(0, (RunInPointX, RunInPointY))
                                densifiedLine.append( (RunOutPointX, RunOutPointY))
                                densifiedLine = LineString(densifiedLine)
                                StopLoggingPoint = len(densifiedLine.coords)-2
                                r =0
                                for p in densifiedLine.coords:
                                    point = xformUTMToWGS84.transform(p[0],p[1])
                                    if r == 0:
                                        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                  self.MAG, self.PB, self.Camera, self.OAS,
                                                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False, "GoTo")
                                    elif r == 1 or r == StopLoggingPoint:
                                        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                self.MAG,self.PB, self.Camera, self.OAS,
                                                self.PlanSpeed, self.PlanHeight, self.Acoms, False,True,"GoTo")
                                    else:
                                        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                  self.MAG,self.PB, self.Camera, self.OAS,
                                                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,"GoTo")
                                    r = r+1
                                    Ln.ListOfGoTosOrCurves.append(GT)

                                if self.selectedManouvres != []:
                                    self.Mission.ListOfManouvres.insert(self.selectedManouvres[0]+1,Ln)
                                    RowToSelect = self.selectedManouvres[0] + 1
                                else:
                                    self.Mission.ListOfManouvres.append(Ln)
                                    RowToSelect = len(self.Mission.ListOfManouvres) - 1
                        self.MissionToBeSaved = True
                        self.ShowAllMissions()
                        self.DisplayMission()
                        self.tableWidget.selectRow(RowToSelect)

    def AddLineWithSurfaceStops(self):
        global xformUTMToWGS84
        if self.Mission is not None:
            layer = self.iface.activeLayer()
            if layer:
                if type(layer).__name__ == "QgsVectorLayer":
                    selection = layer.selectedFeatures()
                    if selection != []:
                        self.RetrieveManouvresSettings()
                        dialog = ResurfacePlanner(self)
                        dialog.resurface_distance_spinBox.setMinimum(self.RunInRunOut+1)
                        dialog.fig8_distance_spinBox.setMinimum(self.RunInRunOut + 1)
                        dialog.resurface_distance_spinBox.setValue(2500)
                        dialog.fig8_distance_spinBox.setValue(1500)
                        dialog.surface_stby_spinBox.setValue(self.StationKeepingDuration)
                        dialog.run_InOut_fig8_spinBox.setValue(self.RunInRunOut)
                        dialog.run_InOut_resurface_spinBox.setValue(self.RunInRunOut)
                        dialog.run_In_line_spinBox_5.setValue(self.RunInRunOut)
                        dialog.run_Out_line_spinBox.setValue(self.RunInRunOut)

                        if dialog.exec():
                            ResurfaceDistance = dialog.ResurfaceDistance
                            Fig8Distance = dialog.Fig8Distance
                            StbyTime = dialog.StbyTime
                            Fig8RunIn = dialog.Fig8RunIn
                            Fig8RunOut = dialog.Fig8RunOut
                            ResurfaceRunIn = dialog.ResurfaceRunIn
                            ResurfaceRunOut = dialog.ResurfaceRunOut
                            TurnSide = dialog.TurnSide
                            Resurface = dialog.Resurface
                            Fig8 = dialog.Fig8
                            LoopsOnAC = dialog.LoopsOnAC
                            LoopsOnACRunIn = dialog.LoopsRunIn
                            LoopsOnACRunOut = dialog.LoopsRunOut
                            LoopsOnACMaxAngle = dialog.LoopsMaxAC
                            LineRunIn = dialog.LineRunIn
                            LineRunOut = dialog.LineRunOut



                            LayerEPSG = layer.crs().authid()
                            crsOrig = QgsCoordinateReferenceSystem(LayerEPSG)
                            crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
                            transformContext = QgsProject.instance().transformContext()
                            xformLayerToWGS84 = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                            for feat in selection:
                                geom = feat.geometry()
                                nVertices = None
                                if geom.isMultipart():  # new part for multipolylines
                                    vertices = geom.asMultiPolyline()
                                    nVertices = ([len(v)for v in vertices])
                                else:
                                    vertices = geom.asPolyline()
                                    nVertices = len(vertices)

                                if nVertices[0] < 4:
                                    geom = geom.densifyByCount(4-nVertices[0])

                                geomSingleType = QgsWkbTypes.isSingleType(geom.wkbType())
                                if geom.type() == QgsWkbTypes.LineGeometry:
                                    name = 'LineWS'
                                    layerFields = layer.fields().names()
                                    id = 0
                                    for field in layerFields:
                                        if field.lower().find('name') != -1:
                                            attr = feat.attributes()[id]
                                            name = 'LineWS - ' +str(attr)
                                            break
                                        else:
                                            id = id +1
                                    Ln = LineWStops([],self.PlanSpeed,self.MBES,self.SSS,self.SBP,self.MAG,self.PB,self.Camera,self.OAS,self.PlanHeight,self.Acoms,name,StbyTime,[])
                                    if geomSingleType:
                                        x = geom.asPolyline()
                                        LineList = []
                                        i = 0
                                        for p in x:
                                            if i == 0:
                                                point = xformLayerToWGS84.transform(p)
                                                UTMEPSG = self.get_utm_zoneEPSG(point.x(),point.y())
                                                crsDest = QgsCoordinateReferenceSystem(UTMEPSG)
                                                crsOrig  = QgsCoordinateReferenceSystem(LayerEPSG)
                                                xformLayerToUTM = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                                                crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
                                                crsOrig  = QgsCoordinateReferenceSystem(UTMEPSG)
                                                xformUTMToWGS84 = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                                            point = xformLayerToUTM.transform(p)
                                            LineList.append(point)
                                            i = i + 1
                                    else:
                                        x = geom.asMultiPolyline()
                                        i = 0
                                        LineList = []
                                        for line in x:
                                            for p in line:
                                                if i == 0:
                                                    point = xformLayerToWGS84.transform(p)
                                                    UTMEPSG = self.get_utm_zoneEPSG(point.x(), point.y())
                                                    crsDest = QgsCoordinateReferenceSystem(UTMEPSG)
                                                    crsOrig = QgsCoordinateReferenceSystem(LayerEPSG)
                                                    xformLayerToUTM = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                                                    crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
                                                    crsOrig = QgsCoordinateReferenceSystem(UTMEPSG)
                                                    xformUTMToWGS84 = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                                                point = xformLayerToUTM.transform(p)
                                                LineList.append(point)
                                                i = i+1

                                    if ResurfaceDistance >= Fig8Distance:
                                        densifyDist = Fig8Distance
                                    else:
                                        densifyDist = ResurfaceDistance

                                    densifiedLine = self.densify_geometry(numpy.array(LineString(LineList).coords),
                                                                          densifyDist/5).tolist()  # densify line using resurface distance to avoid recursions
                                    UTMRunInBearing = 90 - math.degrees(
                                        math.atan2((densifiedLine[0][1] - densifiedLine[1][1]),
                                                   (densifiedLine[0][0] - densifiedLine[1][0])))
                                    if UTMRunInBearing < 0.0:
                                        UTMRunInBearing += 360.0
                                    UTMRunOutBearing = 90 - math.degrees(
                                        math.atan2((densifiedLine[-1][1] - densifiedLine[-2][1]),
                                                   (densifiedLine[-1][0] - densifiedLine[-2][0])))
                                    if UTMRunOutBearing < 0.0:
                                        UTMRunOutBearing += 360.0

                                    UTMRunInBearing = math.radians(UTMRunInBearing)
                                    UTMRunOutBearing = math.radians(UTMRunOutBearing)

                                    RunInPointX = densifiedLine[0][0] + (LineRunIn * math.sin(UTMRunInBearing))
                                    RunInPointY = densifiedLine[0][1] + (LineRunIn * math.cos(UTMRunInBearing))
                                    RunOutPointX = densifiedLine[-1][0] + (LineRunOut * math.sin(UTMRunOutBearing))
                                    RunOutPointY = densifiedLine[-1][1] + (LineRunOut * math.cos(UTMRunOutBearing))
                                    densifiedLine.insert(0, (RunInPointX, RunInPointY))
                                    densifiedLine.append( (RunOutPointX, RunOutPointY))
                                    densifiedLine = LineString(densifiedLine)

                                    distance = ResurfaceDistance  ## starting at first interval
                                    add_distance = ResurfaceDistance  ## eg interpolate every n meter
                                    ResurfacePoints = []
                                    if Resurface == True:
                                        while distance < densifiedLine.length:
                                            new_point = densifiedLine.interpolate(distance)
                                            ResurfacePoints.append([distance,new_point.x, new_point.y,'resurface'])
                                            distance += add_distance


                                    distance = Fig8Distance  ## starting at first interval
                                    add_distance = Fig8Distance  ## eg interpolate every n meter
                                    Fig8DistancePoints = []
                                    if Fig8 == True:
                                        while distance < densifiedLine.length:
                                            new_point = densifiedLine.interpolate(distance)
                                            Fig8DistancePoints.append([distance, new_point.x, new_point.y,'fig8'])
                                            distance += add_distance

                                    counter = 0
                                    for n in ResurfacePoints:
                                        counter2 = 0
                                        indexes = []
                                        for c in  Fig8DistancePoints:
                                            if abs(c[0]-n[0]) <= 250:  #if a fig8 point is closer than 'abs_tol' meters to a surface point the fig8 will be incorporated with the resurface
                                                indexes.append(counter2)
                                                ResurfacePoints[counter][3] = 'resurface & fig8'
                                            counter2 = counter2 + 1
                                        for index in sorted(indexes, reverse=True):
                                            Fig8DistancePoints.pop(index)
                                        counter = counter + 1

                                    ResurfacePoints = sorted(ResurfacePoints + Fig8DistancePoints)

                                    LoopsOnACPoints = []
                                    if LoopsOnAC == True:
                                        counter = 0
                                        for point in densifiedLine.coords:
                                            if counter != 0 and counter < (len(densifiedLine.coords) - 1):

                                                UTMInBearing = 90 - math.degrees(
                                                    math.atan2((point[1] - densifiedLine.coords[counter - 1][1]),
                                                               (point[0] - densifiedLine.coords[counter - 1][0])))
                                                if UTMInBearing < 0.0:
                                                    UTMInBearing += 360.0

                                                UTMOutBearing = 90 - math.degrees(
                                                    math.atan2((densifiedLine.coords[counter + 1][1] -
                                                                point[1]),
                                                               (densifiedLine.coords[counter + 1][0] -
                                                                point[0])))
                                                if UTMOutBearing < 0.0:
                                                    UTMOutBearing += 360.0

                                                InverseUTMOutBearing = UTMOutBearing -180
                                                if InverseUTMOutBearing < 0.0:
                                                    InverseUTMOutBearing += 360.0

                                                AC = min(abs(UTMInBearing - UTMOutBearing), 360 - abs(UTMInBearing - UTMOutBearing))
                                                if AC > LoopsOnACMaxAngle:

                                                    azimuthA = math.radians(UTMOutBearing)
                                                    azimuthB = math.radians(UTMInBearing)

                                                    if InverseUTMOutBearing >= UTMInBearing:
                                                        clockwise_diff = InverseUTMOutBearing - UTMInBearing
                                                    else:
                                                        clockwise_diff = (360 - UTMInBearing) + InverseUTMOutBearing

                                                    counterclockwise_diff = 360 - clockwise_diff

                                                    if (azimuthA > azimuthB) and ((azimuthA - azimuthB) < math.pi):
                                                        #side = 'Portside'
                                                        MidPointLoopAngle = (UTMInBearing - counterclockwise_diff / 2) % 360
                                                    elif (azimuthB > azimuthA) and ((azimuthB - azimuthA) < math.pi):
                                                        #side = 'Starboard'
                                                        MidPointLoopAngle = (UTMInBearing + clockwise_diff / 2) % 360
                                                    elif (azimuthA > azimuthB) and ((azimuthA - azimuthB) > math.pi):
                                                        #side = 'Starboard'
                                                        MidPointLoopAngle = (UTMInBearing + clockwise_diff / 2) % 360
                                                    else:
                                                        #side = 'Portside'
                                                        MidPointLoopAngle = (UTMInBearing - counterclockwise_diff / 2) % 360




                                                    distance = densifiedLine.project(
                                                        shapely.geometry.Point(point[0], point[1]))
                                                    LoopsOnACPoints.append([distance, point[0], point[1], 'loop',MidPointLoopAngle])

                                            counter = counter + 1

                                    counter = 0
                                    for n in ResurfacePoints:
                                        for c in LoopsOnACPoints:
                                            if abs(c[0]-n[0]) <= 50:
                                                if c[0] <= n[0]:
                                                    new_distance = ResurfacePoints[counter][0] + 50
                                                else:
                                                    new_distance = ResurfacePoints[counter][0] - 50
                                                new_point = densifiedLine.interpolate(new_distance)
                                                ResurfacePoints[counter][0] = new_distance
                                                ResurfacePoints[counter][1] = new_point.x
                                                ResurfacePoints[counter][2] = new_point.y
                                                break
                                        counter = counter +1

                                    ResurfacePoints = sorted(ResurfacePoints + LoopsOnACPoints)
                                    StopLoggingPoint = len(densifiedLine.coords) - 2
                                    r = 0
                                    ReSurfacePointsId = 0
                                    for p in densifiedLine.coords:

                                        distancefromorigin = densifiedLine.project(shapely.geometry.Point(p[0], p[1]))

                                        if ReSurfacePointsId < len(ResurfacePoints) and distancefromorigin >= ResurfacePoints[ReSurfacePointsId][0] and r != 0 and r != 1 and r < StopLoggingPoint and distancefromorigin > LineRunIn:
                                            if ResurfacePoints[ReSurfacePointsId][3] == 'resurface':
                                                Ln.ListOfGoTosOrCurves = self.Draw_Resurface(p, ResurfacePoints,
                                                                                             ReSurfacePointsId,
                                                                                             densifiedLine, r, TurnSide,
                                                                                             ResurfaceRunIn,
                                                                                             ResurfaceRunOut,
                                                                                             Ln.ListOfGoTosOrCurves,
                                                                                             StbyTime)
                                            elif ResurfacePoints[ReSurfacePointsId][3] == 'resurface & fig8':
                                                Ln.ListOfGoTosOrCurves = self.Draw_Resurface_Fig8(p, ResurfacePoints,
                                                                                                  ReSurfacePointsId,
                                                                                                  densifiedLine, r,
                                                                                                  TurnSide,
                                                                                                  ResurfaceRunIn,
                                                                                                  ResurfaceRunOut,
                                                                                                  Ln.ListOfGoTosOrCurves,
                                                                                                  StbyTime)
                                            elif ResurfacePoints[ReSurfacePointsId][3] == 'fig8':
                                                Ln.ListOfGoTosOrCurves = self.Draw_Fig_of_8(p, ResurfacePoints,
                                                                                            ReSurfacePointsId,
                                                                                            densifiedLine, r, TurnSide,
                                                                                            Fig8RunIn, Fig8RunOut,
                                                                                            Ln.ListOfGoTosOrCurves)
                                            elif ResurfacePoints[ReSurfacePointsId][3] == 'loop':
                                                Ln.ListOfGoTosOrCurves = self.Draw_AC_Loop(p, ResurfacePoints,
                                                                                           ReSurfacePointsId,
                                                                                           densifiedLine, r,
                                                                                           LoopsOnACRunIn,
                                                                                           LoopsOnACRunOut,
                                                                                           Ln.ListOfGoTosOrCurves)

                                            if ReSurfacePointsId < len(ResurfacePoints)-1:
                                                if ResurfacePoints[ReSurfacePointsId][3] != 'loop' and p[0] == ResurfacePoints[ReSurfacePointsId + 1][1] and \
                                                        p[1] == ResurfacePoints[ReSurfacePointsId + 1][2] and ResurfacePoints[ReSurfacePointsId + 1][3] == 'loop':

                                                    ReSurfacePointsId = ReSurfacePointsId + 1
                                                    Ln.ListOfGoTosOrCurves = self.Draw_AC_Loop(p,ResurfacePoints,ReSurfacePointsId,densifiedLine, r,LoopsOnACRunIn,LoopsOnACRunOut,Ln.ListOfGoTosOrCurves)
                                                else:
                                                    if distancefromorigin > ResurfacePoints[ReSurfacePointsId][0]:
                                                        point = xformUTMToWGS84.transform(p[0], p[1])
                                                        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                                  self.MAG, self.PB, self.Camera, self.OAS,
                                                                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,
                                                                  "GoTo")

                                                        Ln.ListOfGoTosOrCurves.append(GT)
                                            else:
                                                if distancefromorigin > ResurfacePoints[ReSurfacePointsId][0]:
                                                    point = xformUTMToWGS84.transform(p[0], p[1])
                                                    GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                              self.MAG, self.PB, self.Camera, self.OAS,
                                                              self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,
                                                              "GoTo")

                                                    Ln.ListOfGoTosOrCurves.append(GT)



                                            ReSurfacePointsId = ReSurfacePointsId +1

                                        else:

                                            point = xformUTMToWGS84.transform(p[0], p[1])
                                            if r == 0:
                                                GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                          self.MAG, self.PB, self.Camera, self.OAS,
                                                          self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,  # InCurve == True cause is RunIn
                                                          "GoTo")
                                            elif r == 1 or r == StopLoggingPoint:
                                                GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                        self.MAG,self.PB, self.Camera, self.OAS,
                                                        self.PlanSpeed, self.PlanHeight, self.Acoms, False,True,"GoTo")
                                            else:
                                                GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                          self.MAG,self.PB, self.Camera, self.OAS,
                                                          self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,"GoTo")

                                            Ln.ListOfGoTosOrCurves.append(GT)
                                        r = r+1


                                    ###### CREATE THE INVERSE LINE WITH SURFACE STOPS TO BE STORED IN CASE OF REVERSE MANOUVRE CLICK#########

                                    if TurnSide == 'Starboard':
                                        TurnSide = 'Portside'
                                    elif TurnSide == 'Portside':
                                        TurnSide = 'Starboard'

                                    LineList.reverse()
                                    densifiedLine = self.densify_geometry(numpy.array(LineString(LineList).coords),
                                                                          densifyDist / 5).tolist()  # densify line using resurface distance to avoid recursions
                                    UTMRunInBearing = 90 - math.degrees(
                                        math.atan2((densifiedLine[0][1] - densifiedLine[1][1]),
                                                   (densifiedLine[0][0] - densifiedLine[1][0])))
                                    if UTMRunInBearing < 0.0:
                                        UTMRunInBearing += 360.0
                                    UTMRunOutBearing = 90 - math.degrees(
                                        math.atan2((densifiedLine[-1][1] - densifiedLine[-2][1]),
                                                   (densifiedLine[-1][0] - densifiedLine[-2][0])))
                                    if UTMRunOutBearing < 0.0:
                                        UTMRunOutBearing += 360.0

                                    UTMRunInBearing = math.radians(UTMRunInBearing)
                                    UTMRunOutBearing = math.radians(UTMRunOutBearing)

                                    RunInPointX = densifiedLine[0][0] + (LineRunIn * math.sin(UTMRunInBearing))
                                    RunInPointY = densifiedLine[0][1] + (LineRunIn * math.cos(UTMRunInBearing))
                                    RunOutPointX = densifiedLine[-1][0] + (
                                                LineRunOut * math.sin(UTMRunOutBearing))
                                    RunOutPointY = densifiedLine[-1][1] + (
                                                LineRunOut * math.cos(UTMRunOutBearing))
                                    densifiedLine.insert(0, (RunInPointX, RunInPointY))
                                    densifiedLine.append((RunOutPointX, RunOutPointY))
                                    densifiedLine = LineString(densifiedLine)

                                    distance = ResurfaceDistance  ## starting at first interval
                                    add_distance = ResurfaceDistance  ## eg interpolate every n meter
                                    ResurfacePoints = []
                                    if Resurface == True:
                                        while distance < densifiedLine.length:
                                            new_point = densifiedLine.interpolate(distance)
                                            ResurfacePoints.append([distance, new_point.x, new_point.y, 'resurface'])
                                            distance += add_distance

                                    distance = Fig8Distance  ## starting at first interval
                                    add_distance = Fig8Distance  ## eg interpolate every n meter
                                    Fig8DistancePoints = []
                                    if Fig8 == True:
                                        while distance < densifiedLine.length:
                                            new_point = densifiedLine.interpolate(distance)
                                            Fig8DistancePoints.append([distance, new_point.x, new_point.y, 'fig8'])
                                            distance += add_distance

                                    counter = 0
                                    for n in ResurfacePoints:
                                        counter2 = 0
                                        indexes = []
                                        for c in Fig8DistancePoints:
                                            if abs(c[0] - n[
                                                0]) <= 250:  # if a fig8 point is closer than 'abs_tol' meters to a surface point the fig8 will be incorporated with the resurface
                                                indexes.append(counter2)
                                                ResurfacePoints[counter][3] = 'resurface & fig8'
                                            counter2 = counter2 + 1
                                        for index in sorted(indexes, reverse=True):
                                            Fig8DistancePoints.pop(index)
                                        counter = counter + 1

                                    ResurfacePoints = sorted(ResurfacePoints + Fig8DistancePoints)

                                    LoopsOnACPoints = []
                                    if LoopsOnAC == True:
                                        counter = 0
                                        for point in densifiedLine.coords:
                                            if counter != 0 and counter < (len(densifiedLine.coords) - 1):

                                                UTMInBearing = 90 - math.degrees(math.atan2((point[1] - densifiedLine.coords[counter - 1][1]),
                                                               (point[0] - densifiedLine.coords[counter - 1][0])))
                                                if UTMInBearing < 0.0:
                                                    UTMInBearing += 360.0

                                                UTMOutBearing = 90 - math.degrees(
                                                    math.atan2((densifiedLine.coords[counter + 1][1] -
                                                                point[1]),
                                                               (densifiedLine.coords[counter + 1][0] -
                                                                point[0])))
                                                if UTMOutBearing < 0.0:
                                                    UTMOutBearing += 360.0
                                                InverseUTMOutBearing = UTMOutBearing - 180
                                                if InverseUTMOutBearing < 0.0:
                                                    InverseUTMOutBearing += 360.0

                                                AC = min(abs(UTMInBearing - UTMOutBearing),360 - abs(UTMInBearing - UTMOutBearing))
                                                if AC > LoopsOnACMaxAngle:

                                                    azimuthA = math.radians(UTMOutBearing)
                                                    azimuthB = math.radians(UTMInBearing)

                                                    if InverseUTMOutBearing >= UTMInBearing:
                                                        clockwise_diff = InverseUTMOutBearing - UTMInBearing
                                                    else:
                                                        clockwise_diff = (360 - UTMInBearing) + InverseUTMOutBearing

                                                    counterclockwise_diff = 360 - clockwise_diff

                                                    if (azimuthA > azimuthB) and ((azimuthA - azimuthB) < math.pi):
                                                        #side = 'Portside'
                                                        MidPointLoopAngle = (UTMInBearing - counterclockwise_diff / 2) % 360
                                                    elif (azimuthB > azimuthA) and (
                                                            (azimuthB - azimuthA) < math.pi):
                                                        #side = 'Starboard'
                                                        MidPointLoopAngle = (UTMInBearing + clockwise_diff / 2) % 360
                                                    elif (azimuthA > azimuthB) and (
                                                            (azimuthA - azimuthB) > math.pi):
                                                        #side = 'Starboard'
                                                        MidPointLoopAngle = (UTMInBearing + clockwise_diff / 2) % 360
                                                    else:
                                                        #side = 'Portside'
                                                        MidPointLoopAngle = (UTMInBearing - counterclockwise_diff / 2) % 360
                                                    distance = densifiedLine.project(shapely.geometry.Point(point[0], point[1]))
                                                    LoopsOnACPoints.append([distance, point[0], point[1], 'loop',MidPointLoopAngle])

                                            counter = counter + 1

                                    counter = 0
                                    for n in ResurfacePoints:
                                        for c in LoopsOnACPoints:
                                            if abs(c[0] - n[0]) <= 50:
                                                if c[0] <= n[0]:
                                                    new_distance = ResurfacePoints[counter][0] + 50
                                                else:
                                                    new_distance = ResurfacePoints[counter][0] - 50
                                                new_point = densifiedLine.interpolate(new_distance)
                                                ResurfacePoints[counter][0] = new_distance
                                                ResurfacePoints[counter][1] = new_point.x
                                                ResurfacePoints[counter][2] = new_point.y
                                                break
                                        counter = counter + 1

                                    ResurfacePoints = sorted(ResurfacePoints + LoopsOnACPoints)


                                    StopLoggingPoint = len(densifiedLine.coords) - 2
                                    r = 0
                                    ReSurfacePointsId = 0
                                    for p in densifiedLine.coords:
                                        distancefromorigin = densifiedLine.project(shapely.geometry.Point(p[0], p[1]))

                                        if ReSurfacePointsId < len(ResurfacePoints) and distancefromorigin >= \
                                                ResurfacePoints[ReSurfacePointsId][0] and r != 0 and r != 1 and r < StopLoggingPoint and \
                                                distancefromorigin > LineRunIn:

                                            if ResurfacePoints[ReSurfacePointsId][3] == 'resurface':
                                                Ln.InverseListOfGotosOrCurves = self.Draw_Resurface(p, ResurfacePoints,
                                                                                                    ReSurfacePointsId,
                                                                                                    densifiedLine, r,
                                                                                                    TurnSide,
                                                                                                    ResurfaceRunIn,
                                                                                                    ResurfaceRunOut,
                                                                                                    Ln.InverseListOfGotosOrCurves,
                                                                                                    StbyTime)
                                            elif ResurfacePoints[ReSurfacePointsId][3] == 'resurface & fig8':
                                                Ln.InverseListOfGotosOrCurves = self.Draw_Resurface_Fig8(p,
                                                                                                         ResurfacePoints,
                                                                                                         ReSurfacePointsId,
                                                                                                         densifiedLine,
                                                                                                         r, TurnSide,
                                                                                                         ResurfaceRunIn,
                                                                                                         ResurfaceRunOut,
                                                                                                         Ln.InverseListOfGotosOrCurves,
                                                                                                         StbyTime)
                                            elif ResurfacePoints[ReSurfacePointsId][3] == 'fig8':
                                                Ln.InverseListOfGotosOrCurves = self.Draw_Fig_of_8(p, ResurfacePoints,
                                                                                                   ReSurfacePointsId,
                                                                                                   densifiedLine, r,
                                                                                                   TurnSide, Fig8RunIn,
                                                                                                   Fig8RunOut,
                                                                                                   Ln.InverseListOfGotosOrCurves)
                                            elif ResurfacePoints[ReSurfacePointsId][3] == 'loop':
                                                Ln.InverseListOfGotosOrCurves = self.Draw_AC_Loop(p, ResurfacePoints,
                                                                                                  ReSurfacePointsId,
                                                                                                  densifiedLine, r,
                                                                                                  LoopsOnACRunIn,
                                                                                                  LoopsOnACRunOut,
                                                                                                  Ln.InverseListOfGotosOrCurves)
                                            if ReSurfacePointsId < len(ResurfacePoints)-1:
                                                if ResurfacePoints[ReSurfacePointsId][3] != 'loop' and p[0] == ResurfacePoints[ReSurfacePointsId + 1][1] and \
                                                        p[1] == ResurfacePoints[ReSurfacePointsId + 1][2] and ResurfacePoints[ReSurfacePointsId + 1][3] == 'loop':

                                                    ReSurfacePointsId = ReSurfacePointsId + 1
                                                    Ln.InverseListOfGotosOrCurves = self.Draw_AC_Loop(p,ResurfacePoints,ReSurfacePointsId,densifiedLine, r,LoopsOnACRunIn,LoopsOnACRunOut,Ln.InverseListOfGotosOrCurves)
                                                else:
                                                    if distancefromorigin > ResurfacePoints[ReSurfacePointsId][0]:
                                                        point = xformUTMToWGS84.transform(p[0], p[1])
                                                        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                                  self.MAG, self.PB, self.Camera, self.OAS,
                                                                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,
                                                                  "GoTo")

                                                        Ln.InverseListOfGotosOrCurves.append(GT)
                                            else:
                                                if distancefromorigin > ResurfacePoints[ReSurfacePointsId][0]:
                                                    point = xformUTMToWGS84.transform(p[0], p[1])
                                                    GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                              self.MAG, self.PB, self.Camera, self.OAS,
                                                              self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,
                                                              "GoTo")

                                                    Ln.InverseListOfGotosOrCurves.append(GT)

                                            ReSurfacePointsId = ReSurfacePointsId + 1

                                        else:

                                            point = xformUTMToWGS84.transform(p[0], p[1])
                                            if r == 0:
                                                GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                          self.MAG, self.PB, self.Camera, self.OAS,
                                                          self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,  # InCurve == True cause is RunIn
                                                          "GoTo")

                                            elif r == 1 or r == StopLoggingPoint:
                                                GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                          self.MAG, self.PB, self.Camera, self.OAS,
                                                          self.PlanSpeed, self.PlanHeight, self.Acoms, False, True,
                                                          "GoTo")
                                            else:
                                                GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                          self.MAG, self.PB, self.Camera, self.OAS,
                                                          self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,
                                                          "GoTo")

                                            Ln.InverseListOfGotosOrCurves.append(GT)
                                        r = r + 1

                                    if self.selectedManouvres != []:
                                        self.Mission.ListOfManouvres.insert(self.selectedManouvres[0]+1,Ln)
                                        RowToSelect = self.selectedManouvres[0] + 1
                                    else:
                                        self.Mission.ListOfManouvres.append(Ln)
                                        RowToSelect = len(self.Mission.ListOfManouvres) - 1

                            self.MissionToBeSaved = True
                            self.ShowAllMissions()
                            self.DisplayMission()
                            self.tableWidget.selectRow(RowToSelect)

    def Draw_Fig_of_8(self,p,ResurfacePoints,ReSurfacePointsId,densifiedLine,r,TurnSide,RunIn,RunOut,Ln):
        UTMRunInBearing = 90 - math.degrees(
            math.atan2((p[1] - ResurfacePoints[ReSurfacePointsId][2]),
                       (p[0] - ResurfacePoints[ReSurfacePointsId][1])))
        if UTMRunInBearing < 0.0:
            UTMRunInBearing += 360.0

        UTMRunOutBearing = 90 - math.degrees(
            math.atan2((ResurfacePoints[ReSurfacePointsId][2] - densifiedLine.coords[r - 1][1]),
                       (ResurfacePoints[ReSurfacePointsId][1] - densifiedLine.coords[r - 1][0])))
        if UTMRunOutBearing < 0.0:
            UTMRunOutBearing += 360.0

        if TurnSide == 'Starboard':
            CurveSide = 'R'
            OppositeCurveSide = 'L'
            UTMRunOutBearingTurn = UTMRunOutBearing + 90
            if UTMRunOutBearingTurn > 360:
                UTMRunOutBearingTurn = UTMRunOutBearingTurn - 360
            UTMRunInBearingTurn = UTMRunInBearing + 180 + 90
            if UTMRunInBearingTurn > 360:
                UTMRunInBearingTurn = UTMRunInBearingTurn - 360

        else:

            CurveSide = 'L'
            OppositeCurveSide = 'R'
            UTMRunOutBearingTurn = UTMRunOutBearing - 90
            if UTMRunOutBearingTurn < 0.0:
                UTMRunOutBearingTurn += 360.0
            UTMRunInBearingTurn = UTMRunInBearing + 180 - 90
            if UTMRunInBearingTurn > 360:
                UTMRunInBearingTurn = UTMRunInBearingTurn - 360

        InverseUTMRunOutBearing = UTMRunOutBearing + 180
        if InverseUTMRunOutBearing > 360:
            InverseUTMRunOutBearing = InverseUTMRunOutBearing - 360

        InverseUTMRunInBearing = UTMRunInBearing + 180
        if InverseUTMRunInBearing > 360:
            InverseUTMRunInBearing = InverseUTMRunInBearing - 360

        InverseUTMRunOutBearingTurn = UTMRunOutBearingTurn + 180
        if InverseUTMRunOutBearingTurn > 360:
            InverseUTMRunOutBearingTurn = InverseUTMRunOutBearingTurn - 360

        InverseUTMRunInBearingTurn = UTMRunInBearingTurn + 180
        if InverseUTMRunInBearingTurn > 360:
            InverseUTMRunInBearingTurn = InverseUTMRunInBearingTurn - 360

        UTMRunInBearing = math.radians(UTMRunInBearing)
        UTMRunInBearingTurn = math.radians(UTMRunInBearingTurn)
        InverseUTMRunInBearingTurn = math.radians(InverseUTMRunInBearingTurn)
        InverseUTMRunInBearing = math.radians(InverseUTMRunInBearing)
        UTMRunOutBearing = math.radians(UTMRunOutBearing)
        UTMRunOutBearingTurn = math.radians(UTMRunOutBearingTurn)
        InverseUTMRunOutBearingTurn = math.radians(InverseUTMRunOutBearingTurn)
        InverseUTMRunOutBearing = math.radians(InverseUTMRunOutBearing)


        RunOutPointX = ResurfacePoints[ReSurfacePointsId][1] + (
                RunOut * math.sin(UTMRunOutBearing))
        RunOutPointY = ResurfacePoints[ReSurfacePointsId][2] + (
                RunOut * math.cos(UTMRunOutBearing))

        point = xformUTMToWGS84.transform(ResurfacePoints[ReSurfacePointsId][1], ResurfacePoints[ReSurfacePointsId][2])
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, True,
                  "GoTo")
        Ln.append(GT)

        point = xformUTMToWGS84.transform(RunOutPointX,
                                          RunOutPointY)
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,
                  "GoTo")
        Ln.append(GT)

        radius = self.CurveRadius
        x = RunOutPointX + (radius * math.sin(UTMRunOutBearingTurn))
        y = RunOutPointY + (radius * math.cos(UTMRunOutBearingTurn))
        CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
        x = x + (radius * math.sin(UTMRunOutBearing))
        y = y + (radius * math.cos(UTMRunOutBearing))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
        Ln.append(Cur)

        x = RunOutPointX + ((radius * 2) * math.sin(UTMRunOutBearingTurn))
        y = RunOutPointY + ((radius * 2) * math.cos(UTMRunOutBearingTurn))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
        Ln.append(Cur)

        x = x + (RunOut * math.sin(InverseUTMRunOutBearing))
        y = y + (RunOut * math.cos(InverseUTMRunOutBearing))
        point = xformUTMToWGS84.transform(QgsPointXY(x, y))

        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,
                  "GoTo")
        Ln.append(GT)

        x = x + (RunIn * math.sin(InverseUTMRunInBearing))
        y = y + (RunIn * math.cos(InverseUTMRunInBearing))
        X = x
        Y = y
        point = xformUTMToWGS84.transform(QgsPointXY(x, y))
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,
                  "GoTo")
        Ln.append(GT)

        x = x + (radius * math.sin(InverseUTMRunInBearingTurn))
        y = y + (radius * math.cos(InverseUTMRunInBearingTurn))
        CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
        x = x + (radius * math.sin(InverseUTMRunInBearing))
        y = y + (radius * math.cos(InverseUTMRunInBearing))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, OppositeCurveSide)
        Ln.append(Cur)

        x = X + ((radius * 2) * math.sin(InverseUTMRunInBearingTurn))
        y = Y + ((radius * 2) * math.cos(InverseUTMRunInBearingTurn))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, OppositeCurveSide)
        Ln.append(Cur)

        x = x + (RunIn * math.sin(UTMRunInBearing))
        y = y + (RunIn * math.cos(UTMRunInBearing))
        point = xformUTMToWGS84.transform(QgsPointXY(x, y))
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,
                  "GoTo")
        Ln.append(GT)

        x = x + (RunOut * math.sin(UTMRunOutBearing))
        y = y + (RunOut * math.cos(UTMRunOutBearing))
        X = x
        Y = y
        point = xformUTMToWGS84.transform(QgsPointXY(x, y))
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,
                  "GoTo")
        Ln.append(GT)


        x = x + (radius * math.sin(InverseUTMRunOutBearingTurn))
        y = y + (radius * math.cos(InverseUTMRunOutBearingTurn))
        CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
        x = x + (radius * math.sin(UTMRunOutBearing))
        y = y + (radius * math.cos(UTMRunOutBearing))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, OppositeCurveSide)
        Ln.append(Cur)

        x = X + ((radius * 2) * math.sin(InverseUTMRunOutBearingTurn))
        y = Y + ((radius * 2) * math.cos(InverseUTMRunOutBearingTurn))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, OppositeCurveSide)
        Ln.append(Cur)

        x = x + (RunOut * math.sin(InverseUTMRunOutBearing))
        y = y + (RunOut * math.cos(InverseUTMRunOutBearing))
        point = xformUTMToWGS84.transform(QgsPointXY(x, y))
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,
                  "GoTo")
        Ln.append(GT)

        x = x + (RunIn * math.sin(InverseUTMRunInBearing))
        y = y + (RunIn * math.cos(InverseUTMRunInBearing))
        X = x
        Y = y
        point = xformUTMToWGS84.transform(QgsPointXY(x, y))
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,
                  "GoTo")
        Ln.append(GT)

        x = x + (radius * math.sin(UTMRunInBearingTurn))
        y = y + (radius * math.cos(UTMRunInBearingTurn))
        CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
        x = x + (radius * math.sin(InverseUTMRunInBearing))
        y = y + (radius * math.cos(InverseUTMRunInBearing))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
        Ln.append(Cur)

        x = X + ((radius * 2) * math.sin(UTMRunInBearingTurn))
        y = Y + ((radius * 2) * math.cos(UTMRunInBearingTurn))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
        Ln.append(Cur)


        point = xformUTMToWGS84.transform(ResurfacePoints[ReSurfacePointsId][1],
                                          ResurfacePoints[ReSurfacePointsId][2])
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,
                  "GoTo")
        Ln.append(GT)


        return Ln

    def Draw_AC_Loop(self,p,ResurfacePoints,ReSurfacePointsId,densifiedLine,r,RunIn,RunOut,Ln):
        UTMRunInBearing = 90 - math.degrees(
            math.atan2((ResurfacePoints[ReSurfacePointsId][2] - densifiedLine.coords[r + 1][1]),
                       (ResurfacePoints[ReSurfacePointsId][1] - densifiedLine.coords[r + 1][0])))
        if UTMRunInBearing < 0.0:
            UTMRunInBearing += 360.0


        UTMRunOutBearing = 90 - math.degrees(
            math.atan2((ResurfacePoints[ReSurfacePointsId][2] - densifiedLine.coords[r - 1][1]),
                       (ResurfacePoints[ReSurfacePointsId][1] - densifiedLine.coords[r - 1][0])))

        if UTMRunOutBearing < 0.0:
            UTMRunOutBearing += 360.0

        UTMRunInBearing = math.radians(UTMRunInBearing)

        UTMRunOutBearing = math.radians(UTMRunOutBearing)


        RunOutPointX = ResurfacePoints[ReSurfacePointsId][1] + (
                RunOut * math.sin(UTMRunOutBearing))
        RunOutPointY = ResurfacePoints[ReSurfacePointsId][2] + (
                RunOut * math.cos(UTMRunOutBearing))

        point = xformUTMToWGS84.transform(ResurfacePoints[ReSurfacePointsId][1], ResurfacePoints[ReSurfacePointsId][2])
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, True,
                  "GoTo")
        Ln.append(GT)

        point = xformUTMToWGS84.transform(RunOutPointX,
                                          RunOutPointY)
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,
                  "GoTo")
        Ln.append(GT)


        MidPointX = ResurfacePoints[ReSurfacePointsId][1] + (
            (RunOut*1.3) * math.sin(math.radians(ResurfacePoints[ReSurfacePointsId][4])))
        MidPointY = ResurfacePoints[ReSurfacePointsId][2] + (
                (RunOut*1.3) * math.cos(math.radians(ResurfacePoints[ReSurfacePointsId][4])))
        
        point = xformUTMToWGS84.transform(MidPointX,
                                          MidPointY)
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,
                  "GoTo")
        Ln.append(GT)

        RunInPointX = ResurfacePoints[ReSurfacePointsId][1] + (
                RunIn * math.sin(UTMRunInBearing))
        RunInPointY = ResurfacePoints[ReSurfacePointsId][2] + (
                RunIn * math.cos(UTMRunInBearing))

        point = xformUTMToWGS84.transform(RunInPointX,
                                          RunInPointY)
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,
                  "GoTo")
        Ln.append(GT)


        point = xformUTMToWGS84.transform(ResurfacePoints[ReSurfacePointsId][1],
                                          ResurfacePoints[ReSurfacePointsId][2])
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,
                  "GoTo")
        Ln.append(GT)



        return Ln

    def Draw_Resurface(self,p,ResurfacePoints,ReSurfacePointsId,densifiedLine,r,TurnSide,RunIn,RunOut,Ln,
                       StbyTime):

        UTMRunInBearing = 90 - math.degrees(
            math.atan2((p[1] - ResurfacePoints[ReSurfacePointsId][2]),
                       (p[0] - ResurfacePoints[ReSurfacePointsId][1])))
        if UTMRunInBearing < 0.0:
            UTMRunInBearing += 360.0

        UTMRunOutBearing = 90 - math.degrees(
            math.atan2((ResurfacePoints[ReSurfacePointsId][2] - densifiedLine.coords[r - 1][1]),
                       (ResurfacePoints[ReSurfacePointsId][1] - densifiedLine.coords[r - 1][0])))
        if UTMRunOutBearing < 0.0:
            UTMRunOutBearing += 360.0

        if TurnSide == 'Starboard':
            CurveSide = 'R'
            UTMRunOutBearingTurn = UTMRunOutBearing + 90
            if UTMRunOutBearingTurn > 360:
                UTMRunOutBearingTurn = UTMRunOutBearingTurn - 360
            UTMRunInBearingTurn = UTMRunInBearing + 180 + 90
            if UTMRunInBearingTurn > 360:
                UTMRunInBearingTurn = UTMRunInBearingTurn - 360

        else:

            CurveSide = 'L'
            UTMRunOutBearingTurn = UTMRunOutBearing - 90
            if UTMRunOutBearingTurn < 0.0:
                UTMRunOutBearingTurn += 360.0
            UTMRunInBearingTurn = UTMRunInBearing + 180 - 90
            if UTMRunInBearingTurn > 360:
                UTMRunInBearingTurn = UTMRunInBearingTurn - 360

        InverseUTMRunOutBearing = UTMRunOutBearing + 180
        if InverseUTMRunOutBearing > 360:
            InverseUTMRunOutBearing = InverseUTMRunOutBearing - 360

        InverseUTMRunInBearing = UTMRunInBearing + 180
        if InverseUTMRunInBearing > 360:
            InverseUTMRunInBearing = InverseUTMRunInBearing - 360

        UTMRunInBearing = math.radians(UTMRunInBearing)
        UTMRunInBearingTurn = math.radians(UTMRunInBearingTurn)
        InverseUTMRunInBearing = math.radians(InverseUTMRunInBearing)
        UTMRunOutBearing = math.radians(UTMRunOutBearing)
        UTMRunOutBearingTurn = math.radians(UTMRunOutBearingTurn)
        InverseUTMRunOutBearing = math.radians(InverseUTMRunOutBearing)


        RunOutPointX = ResurfacePoints[ReSurfacePointsId][1] + (
                RunOut * math.sin(UTMRunOutBearing))
        RunOutPointY = ResurfacePoints[ReSurfacePointsId][2] + (
                RunOut * math.cos(UTMRunOutBearing))

        point = xformUTMToWGS84.transform(ResurfacePoints[ReSurfacePointsId][1], ResurfacePoints[ReSurfacePointsId][2])
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, True,
                  "GoTo")
        Ln.append(GT)

        point = xformUTMToWGS84.transform(RunOutPointX,
                                          RunOutPointY)
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,
                  "GoTo")
        Ln.append(GT)

        radius = self.CurveRadius
        x = RunOutPointX + (radius * math.sin(UTMRunOutBearingTurn))
        y = RunOutPointY + (radius * math.cos(UTMRunOutBearingTurn))
        CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
        x = x + (radius * math.sin(UTMRunOutBearing))
        y = y + (radius * math.cos(UTMRunOutBearing))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
        Ln.append(Cur)

        x = RunOutPointX + ((radius * 2) * math.sin(UTMRunOutBearingTurn))
        y = RunOutPointY + ((radius * 2) * math.cos(UTMRunOutBearingTurn))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
        Ln.append(Cur)

        x = x + (RunOut * math.sin(InverseUTMRunOutBearing))
        y = y + (RunOut * math.cos(InverseUTMRunOutBearing))
        point = xformUTMToWGS84.transform(QgsPointXY(x, y))

        SK = StationKeeping(point, self.MBES, self.SSS, self.SBP,
                            self.MAG, self.PB, self.Camera, self.OAS,
                            self.PlanSpeed, (0.0, 1), self.Acoms,
                            # Depth is set to 0 Depth by default for station keeping at surface for GNSS acquisition
                            StbyTime, "Station Keeping at surface")
        Ln.append(SK)

        x = x + (RunIn * math.sin(InverseUTMRunInBearing))
        y = y + (RunIn * math.cos(InverseUTMRunInBearing))
        X = x
        Y = y
        point = xformUTMToWGS84.transform(QgsPointXY(x, y))
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,
                  "GoTo")
        Ln.append(GT)

        x = x + (radius * math.sin(UTMRunInBearingTurn))
        y = y + (radius * math.cos(UTMRunInBearingTurn))
        CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
        x = x + (radius * math.sin(InverseUTMRunInBearing))
        y = y + (radius * math.cos(InverseUTMRunInBearing))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
        Ln.append(Cur)

        x = X + ((radius * 2) * math.sin(UTMRunInBearingTurn))
        y = Y + ((radius * 2) * math.cos(UTMRunInBearingTurn))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
        Ln.append(Cur)

        point = xformUTMToWGS84.transform(ResurfacePoints[ReSurfacePointsId][1],
                                          ResurfacePoints[ReSurfacePointsId][2])
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,
                  "GoTo")
        Ln.append(GT)

        return Ln

    def Draw_Resurface_Fig8(self, p, ResurfacePoints, ReSurfacePointsId, densifiedLine, r, TurnSide, RunIn, RunOut, Ln,
                       StbyTime):
        UTMRunInBearing = 90 - math.degrees(
            math.atan2((p[1] - ResurfacePoints[ReSurfacePointsId][2]),
                       (p[0] - ResurfacePoints[ReSurfacePointsId][1])))
        if UTMRunInBearing < 0.0:
            UTMRunInBearing += 360.0

        UTMRunOutBearing = 90 - math.degrees(
            math.atan2((ResurfacePoints[ReSurfacePointsId][2] - densifiedLine.coords[r - 1][1]),
                       (ResurfacePoints[ReSurfacePointsId][1] - densifiedLine.coords[r - 1][0])))
        if UTMRunOutBearing < 0.0:
            UTMRunOutBearing += 360.0

        if TurnSide == 'Starboard':
            CurveSide = 'R'
            OppositeCurveSide = 'L'
            UTMRunOutBearingTurn = UTMRunOutBearing + 90
            if UTMRunOutBearingTurn > 360:
                UTMRunOutBearingTurn = UTMRunOutBearingTurn - 360
            UTMRunInBearingTurn = UTMRunInBearing + 180 + 90
            if UTMRunInBearingTurn > 360:
                UTMRunInBearingTurn = UTMRunInBearingTurn - 360

        else:

            CurveSide = 'L'
            OppositeCurveSide = 'R'
            UTMRunOutBearingTurn = UTMRunOutBearing - 90
            if UTMRunOutBearingTurn < 0.0:
                UTMRunOutBearingTurn += 360.0
            UTMRunInBearingTurn = UTMRunInBearing + 180 - 90
            if UTMRunInBearingTurn > 360:
                UTMRunInBearingTurn = UTMRunInBearingTurn - 360

        InverseUTMRunOutBearing = UTMRunOutBearing + 180
        if InverseUTMRunOutBearing > 360:
            InverseUTMRunOutBearing = InverseUTMRunOutBearing - 360

        InverseUTMRunInBearing = UTMRunInBearing + 180
        if InverseUTMRunInBearing > 360:
            InverseUTMRunInBearing = InverseUTMRunInBearing - 360

        InverseUTMRunOutBearingTurn = UTMRunOutBearingTurn + 180
        if InverseUTMRunOutBearingTurn > 360:
            InverseUTMRunOutBearingTurn = InverseUTMRunOutBearingTurn - 360

        InverseUTMRunInBearingTurn = UTMRunInBearingTurn + 180
        if InverseUTMRunInBearingTurn > 360:
            InverseUTMRunInBearingTurn = InverseUTMRunInBearingTurn - 360

        UTMRunInBearing = math.radians(UTMRunInBearing)
        UTMRunInBearingTurn = math.radians(UTMRunInBearingTurn)
        InverseUTMRunInBearingTurn = math.radians(InverseUTMRunInBearingTurn)
        InverseUTMRunInBearing = math.radians(InverseUTMRunInBearing)
        UTMRunOutBearing = math.radians(UTMRunOutBearing)
        UTMRunOutBearingTurn = math.radians(UTMRunOutBearingTurn)
        InverseUTMRunOutBearingTurn = math.radians(InverseUTMRunOutBearingTurn)
        InverseUTMRunOutBearing = math.radians(InverseUTMRunOutBearing)


        RunOutPointX = ResurfacePoints[ReSurfacePointsId][1] + (
                RunOut * math.sin(UTMRunOutBearing))
        RunOutPointY = ResurfacePoints[ReSurfacePointsId][2] + (
                RunOut * math.cos(UTMRunOutBearing))

        point = xformUTMToWGS84.transform(ResurfacePoints[ReSurfacePointsId][1], ResurfacePoints[ReSurfacePointsId][2])
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, True,
                  "GoTo")
        Ln.append(GT)

        point = xformUTMToWGS84.transform(RunOutPointX,
                                          RunOutPointY)
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,
                  "GoTo")
        Ln.append(GT)

        radius = self.CurveRadius
        x = RunOutPointX + (radius * math.sin(UTMRunOutBearingTurn))
        y = RunOutPointY + (radius * math.cos(UTMRunOutBearingTurn))
        CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
        x = x + (radius * math.sin(UTMRunOutBearing))
        y = y + (radius * math.cos(UTMRunOutBearing))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
        Ln.append(Cur)

        x = RunOutPointX + ((radius * 2) * math.sin(UTMRunOutBearingTurn))
        y = RunOutPointY + ((radius * 2) * math.cos(UTMRunOutBearingTurn))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
        Ln.append(Cur)

        x = x + (RunOut * math.sin(InverseUTMRunOutBearing))
        y = y + (RunOut * math.cos(InverseUTMRunOutBearing))
        point = xformUTMToWGS84.transform(QgsPointXY(x, y))

        SK = StationKeeping(point, self.MBES, self.SSS, self.SBP,
                            self.MAG, self.PB, self.Camera, self.OAS,
                            self.PlanSpeed, (0.0, 1), self.Acoms,
                            # Depth is set to 0 Depth by default for station keeping at surface for GNSS acquisition
                            StbyTime, "Station Keeping at surface")
        Ln.append(SK)

        x = x + (RunIn * math.sin(InverseUTMRunInBearing))
        y = y + (RunIn * math.cos(InverseUTMRunInBearing))
        X = x
        Y = y
        point = xformUTMToWGS84.transform(QgsPointXY(x, y))
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,
                  "GoTo")
        Ln.append(GT)

        x = x + (radius * math.sin(InverseUTMRunInBearingTurn))
        y = y + (radius * math.cos(InverseUTMRunInBearingTurn))
        CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
        x = x + (radius * math.sin(InverseUTMRunInBearing))
        y = y + (radius * math.cos(InverseUTMRunInBearing))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, OppositeCurveSide)
        Ln.append(Cur)

        x = X + ((radius * 2) * math.sin(InverseUTMRunInBearingTurn))
        y = Y + ((radius * 2) * math.cos(InverseUTMRunInBearingTurn))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, OppositeCurveSide)
        Ln.append(Cur)

        x = x + (RunIn * math.sin(UTMRunInBearing))
        y = y + (RunIn * math.cos(UTMRunInBearing))
        point = xformUTMToWGS84.transform(QgsPointXY(x, y))
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,
                  "GoTo")
        Ln.append(GT)

        x = x + (RunOut * math.sin(UTMRunOutBearing))
        y = y + (RunOut * math.cos(UTMRunOutBearing))
        X = x
        Y = y
        point = xformUTMToWGS84.transform(QgsPointXY(x, y))
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,
                  "GoTo")
        Ln.append(GT)

        x = x + (radius * math.sin(InverseUTMRunOutBearingTurn))
        y = y + (radius * math.cos(InverseUTMRunOutBearingTurn))
        CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
        x = x + (radius * math.sin(UTMRunOutBearing))
        y = y + (radius * math.cos(UTMRunOutBearing))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, OppositeCurveSide)
        Ln.append(Cur)

        x = X + ((radius * 2) * math.sin(InverseUTMRunOutBearingTurn))
        y = Y + ((radius * 2) * math.cos(InverseUTMRunOutBearingTurn))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, OppositeCurveSide)
        Ln.append(Cur)

        x = x + (RunOut * math.sin(InverseUTMRunOutBearing))
        y = y + (RunOut * math.cos(InverseUTMRunOutBearing))
        point = xformUTMToWGS84.transform(QgsPointXY(x, y))
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,
                  "GoTo")
        Ln.append(GT)

        x = x + (RunIn * math.sin(InverseUTMRunInBearing))
        y = y + (RunIn * math.cos(InverseUTMRunInBearing))
        X = x
        Y = y
        point = xformUTMToWGS84.transform(QgsPointXY(x, y))
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False,
                  "GoTo")
        Ln.append(GT)

        x = x + (radius * math.sin(UTMRunInBearingTurn))
        y = y + (radius * math.cos(UTMRunInBearingTurn))
        CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
        x = x + (radius * math.sin(InverseUTMRunInBearing))
        y = y + (radius * math.cos(InverseUTMRunInBearing))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
        Ln.append(Cur)

        x = X + ((radius * 2) * math.sin(UTMRunInBearingTurn))
        y = Y + ((radius * 2) * math.cos(UTMRunInBearingTurn))
        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                    self.MAG, self.PB, self.Camera, self.OAS,
                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
        Ln.append(Cur)

        point = xformUTMToWGS84.transform(ResurfacePoints[ReSurfacePointsId][1],
                                          ResurfacePoints[ReSurfacePointsId][2])
        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                  self.MAG, self.PB, self.Camera, self.OAS,
                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,
                  "GoTo")
        Ln.append(GT)

        return Ln

    def AddGoTo(self,coordinates):
        if self.Mission is not None:
            if self.EnableAddRowsMapTool == False and self.EnableAddStationKeepingMapTool == False:
                if self.EnableAddGoToMapTool == True:
                    self.RetrieveManouvresSettings()
                    self.AddGoToMapTool.deactivate()
                    self.canvas.unsetMapTool(self.AddGoToMapTool)
                    self.EnableAddGoToMapTool = False
                    self.AddGoTo_pushButton.setChecked(False)
                    if coordinates != False and coordinates != True and coordinates != []:
                        for p in coordinates:
                            point = self.xformMapCrsToWGS84.transform(p)
                            GT = GoTo(point,self.MBES,self.SSS,self.SBP,
                                      self.MAG,self.PB, self.Camera,self.OAS,
                                      self.PlanSpeed,self.PlanHeight,self.Acoms,True,False,"GoTo")
                            if self.Mission is not None:
                                if self.selectedManouvres != []:
                                    self.Mission.ListOfManouvres.insert(self.selectedManouvres[0] + 1,GT)
                                    RowToSelect = self.selectedManouvres[0] + 1
                                else:
                                    self.Mission.ListOfManouvres.append(GT)
                                    RowToSelect = len(self.Mission.ListOfManouvres)-1
                            self.MissionToBeSaved = True
                            self.ShowAllMissions()
                            self.DisplayMission()
                            self.tableWidget.selectRow(RowToSelect)
                else:
                    if self.Mission.ListOfManouvres != []:
                        if self.selectedManouvres == []:
                            Manouvre = self.Mission.ListOfManouvres[-1]
                        else:
                            Manouvre = self.Mission.ListOfManouvres[self.selectedManouvres[0]]
                        if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                            self.AddGoToMapTool.lastMissionPoint = self.xformMapCrsToWGS84.transform(QgsPointXY(Manouvre.DestPointX, Manouvre.DestPointY),QgsCoordinateTransform.ReverseTransform)
                        else:
                            self.AddGoToMapTool.lastMissionPoint = self.xformMapCrsToWGS84.transform(QgsPointXY(Manouvre.ListOfGoTosOrCurves[-1].DestPointX, Manouvre.ListOfGoTosOrCurves[-1].DestPointY),QgsCoordinateTransform.ReverseTransform)
                        if self.selectedManouvres == []:
                            self.selectedManouvres = [len(self.Mission.ListOfManouvres)-1]
                        if self.selectedManouvres[0] < (len(self.Mission.ListOfManouvres)-1):
                            Manouvre = self.Mission.ListOfManouvres[self.selectedManouvres[0]+1]
                            if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                                self.AddGoToMapTool.nextMissionPoint = self.xformMapCrsToWGS84.transform(
                                    QgsPointXY(Manouvre.DestPointX, Manouvre.DestPointY),
                                    QgsCoordinateTransform.ReverseTransform)
                            else:
                                self.AddGoToMapTool.nextMissionPoint = self.xformMapCrsToWGS84.transform(
                                    QgsPointXY(Manouvre.ListOfGoTosOrCurves[0].DestPointX,
                                               Manouvre.ListOfGoTosOrCurves[0].DestPointY),
                                    QgsCoordinateTransform.ReverseTransform)
                        else:
                            self.AddGoToMapTool.nextMissionPoint = None


                    else:
                        self.AddGoToMapTool.lastMissionPoint = None
                        self.AddGoToMapTool.nextMissionPoint = None

                    self.canvas.setMapTool(self.AddGoToMapTool)
                    self.EnableAddGoToMapTool = True
                    self.AddGoTo_pushButton.setChecked(True)
            else:
                self.AddGoTo_pushButton.setChecked(False)
        else:
            self.AddGoTo_pushButton.setChecked(False)

    def AddStationKeeping(self,coordinates):
        if self.Mission is not None:
            if self.EnableAddRowsMapTool == False and self.EnableAddGoToMapTool == False:
                if self.EnableAddStationKeepingMapTool == True:
                    self.RetrieveManouvresSettings()
                    self.AddStationKeepingMapTool.deactivate()
                    self.canvas.unsetMapTool(self.AddStationKeepingMapTool)
                    self.EnableAddStationKeepingMapTool = False
                    self.AddStationKeeping_pushButton.setChecked(False)
                    if coordinates != False and coordinates != True and coordinates != []:
                        for p in coordinates:
                            point = self.xformMapCrsToWGS84.transform(p)
                            SK = StationKeeping(point, self.MBES, self.SSS, self.SBP,
                                      self.MAG,self.PB, self.Camera, self.OAS,
                                      self.PlanSpeed, self.PlanHeight, self.Acoms,self.StationKeepingDuration,"Station Keeping")
                            if self.Mission is not None:
                                if self.selectedManouvres != []:
                                    self.Mission.ListOfManouvres.insert(self.selectedManouvres[0] + 1, SK)
                                    RowToSelect = self.selectedManouvres[0] + 1
                                else:
                                    self.Mission.ListOfManouvres.append(SK)
                                    RowToSelect = len(self.Mission.ListOfManouvres) - 1
                                self.MissionToBeSaved = True
                                self.ShowAllMissions()
                                self.DisplayMission()
                                self.tableWidget.selectRow(RowToSelect)
                else:
                    if self.Mission.ListOfManouvres != []:
                        if self.selectedManouvres == []:
                            Manouvre = self.Mission.ListOfManouvres[-1]
                        else:
                            Manouvre = self.Mission.ListOfManouvres[self.selectedManouvres[0]]
                        if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                            self.AddStationKeepingMapTool.lastMissionPoint = self.xformMapCrsToWGS84.transform(QgsPointXY(Manouvre.DestPointX, Manouvre.DestPointY),QgsCoordinateTransform.ReverseTransform)
                        else:
                            self.AddStationKeepingMapTool.lastMissionPoint = self.xformMapCrsToWGS84.transform(QgsPointXY(Manouvre.ListOfGoTosOrCurves[-1].DestPointX, Manouvre.ListOfGoTosOrCurves[-1].DestPointY),QgsCoordinateTransform.ReverseTransform)
                        if self.selectedManouvres == []:
                            self.selectedManouvres = [len(self.Mission.ListOfManouvres)-1]
                        if self.selectedManouvres[0] < (len(self.Mission.ListOfManouvres)-1):
                            Manouvre = self.Mission.ListOfManouvres[self.selectedManouvres[0]+1]
                            if Manouvre.type == 'GoTo' or Manouvre.type == 'SK':
                                self.AddStationKeepingMapTool.nextMissionPoint = self.xformMapCrsToWGS84.transform(
                                    QgsPointXY(Manouvre.DestPointX, Manouvre.DestPointY),
                                    QgsCoordinateTransform.ReverseTransform)
                            else:
                                self.AddStationKeepingMapTool.nextMissionPoint = self.xformMapCrsToWGS84.transform(
                                    QgsPointXY(Manouvre.ListOfGoTosOrCurves[0].DestPointX,
                                               Manouvre.ListOfGoTosOrCurves[0].DestPointY),
                                    QgsCoordinateTransform.ReverseTransform)
                        else:
                            self.AddStationKeepingMapTool.nextMissionPoint = None


                    else:
                        self.AddStationKeepingMapTool.lastMissionPoint = None
                        self.AddStationKeepingMapTool.nextMissionPoint = None

                    self.canvas.setMapTool(self.AddStationKeepingMapTool)
                    self.EnableAddStationKeepingMapTool = True
                    self.AddStationKeeping_pushButton.setChecked(True)
            else:
                self.AddStationKeeping_pushButton.setChecked(False)
        else:
            self.AddStationKeeping_pushButton.setChecked(False)

    def AddRows(self, data):
        if self.EnableAddStationKeepingMapTool == False and self.EnableAddGoToMapTool == False:
            if self.EnableAddRowsMapTool == True:
                self.AddRowsMapTool.deactivate()
                self.canvas.unsetMapTool(self.AddRowsMapTool)
                self.EnableAddRowsMapTool = False
                self.AddRows_pushButton.setChecked(False)
                if data != False and data != True and data != []:
                    self.DrawRows(data)
            else:
                self.canvas.setMapTool(self.AddRowsMapTool)
                self.EnableAddRowsMapTool = True
                self.AddRows_pushButton.setChecked(True)
        else:
            self.AddRows_pushButton.setChecked(False)

    def DrawRows(self, data):
        self.RetrieveManouvresSettings()
        RowToAdd = Rows([], self.PlanSpeed, self.MBES, self.SSS, self.SBP, self.MAG, self.PB, self.Camera, self.OAS,
                        self.PlanHeight, self.Acoms, "Rows", [])

        Point1UTM = data[0][1]
        Point2UTM = data[1][1]
        Point3UTM = data[2][1]
        Point4UTM = data[3][1]
        UTMEPSG = data[4]
        side = data[5]

        crsOrig = QgsCoordinateReferenceSystem(UTMEPSG)
        crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
        transformContext = QgsProject.instance().transformContext()
        xformUTMToWGS84 = QgsCoordinateTransform(crsOrig, crsDest, transformContext)

        UTMBearing12 = 90 - math.degrees(math.atan2((Point2UTM.y() - Point1UTM.y()), (Point2UTM.x() - Point1UTM.x())))
        if UTMBearing12 < 0.0:
            UTMBearing12 += 360.0
        elif UTMBearing12 > 360.0:
            UTMBearing12 = UTMBearing12 - 360.0
        InverseUTMBearing12 = UTMBearing12 + 180
        if InverseUTMBearing12 > 360.0:
            InverseUTMBearing12 = InverseUTMBearing12 - 360.0
        UTMBearing12 = math.radians(UTMBearing12)
        InverseUTMBearing12 = math.radians(InverseUTMBearing12)
        x = Point1UTM.x() + (self.RunInRunOut * math.sin(InverseUTMBearing12))
        y = Point1UTM.y() + (self.RunInRunOut * math.cos(InverseUTMBearing12))
        RunInPoint = QgsPointXY(x,y)
        x = Point2UTM.x() + (self.RunInRunOut * math.sin(UTMBearing12))
        y = Point2UTM.y() + (self.RunInRunOut * math.cos(UTMBearing12))
        RunOutPoint = QgsPointXY(x, y)
        SurveyLine = self.densify_geometry(numpy.array(LineString([Point1UTM, Point2UTM]).coords),self.MaxDistance)
        SurveyLine = LineString(SurveyLine.tolist())
        TotalLineList = [RunInPoint]
        for point in list(SurveyLine.coords):
            TotalLineList.append(point)
        TotalLineList.append(RunOutPoint)
        BaseLine = LineString(TotalLineList)
        BaseLine = BaseLine.parallel_offset(self.LineSpacing / 3,side, resolution=16, join_style=2, mitre_limit=1.0)
        if BaseLine.geom_type != 'LineString' and shapely.__version__ >= '2.0.0:':
            try:
                BaseLine = ops.linemerge(BaseLine)
            except:
                BaseLine = BaseLine.geoms[0]

        if side == 'right':
            if shapely.__version__ <= '1.9.9:':
                coords = [tuple(coord) for coord in list(BaseLine.coords)][::-1]
                BaseLine = LineString(coords)
            else:
                coords = [tuple(coord) for coord in list(BaseLine.coords)][::-1]
                coords.reverse()
                BaseLine = LineString(coords)

        StopLoggingPoint = len(BaseLine.coords) - 2
        r = 0

        for coords in BaseLine.coords:
            point = xformUTMToWGS84.transform(QgsPointXY(coords[0],coords[1]))
            if r == 0:
                GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                          self.MAG, self.PB, self.Camera, self.OAS,
                          self.PlanSpeed, self.PlanHeight, self.Acoms, True, False, "GoTo")

            elif r == 1 or r == StopLoggingPoint:
                GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                        self.MAG, self.PB, self.Camera, self.OAS,
                        self.PlanSpeed, self.PlanHeight, self.Acoms,False,True, "GoTo")
            else:
                GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                          self.MAG, self.PB, self.Camera, self.OAS,
                          self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,"GoTo")
            r = r+1
            RowToAdd.ListOfGoTosOrCurves.append(GT)

        Dist23 = math.dist(Point2UTM, Point3UTM)
        NumberOfLines = math.ceil(Dist23/self.LineSpacing)-1

        LastPoint = QgsPointXY(BaseLine.coords[-1][0], BaseLine.coords[-1][1])

        UTMBearing23 = 90 - math.degrees(math.atan2((Point3UTM.y() - Point2UTM.y()), (Point3UTM.x() - Point2UTM.x())))
        if UTMBearing23 < 0.0:
            UTMBearing23 += 360.0
        elif UTMBearing23 > 360.0:
            UTMBearing23 = UTMBearing23 - 360.0
        InverseUTMBearing23 = UTMBearing23 + 180
        if InverseUTMBearing23 > 360.0:
            InverseUTMBearing23 = InverseUTMBearing23 - 360.0
        UTMBearing23 = math.radians(UTMBearing23)
        InverseUTMBearing23 = math.radians(InverseUTMBearing23)
        if side == 'right':
            CurveSide = 'R'
        else:
            CurveSide = 'L'
        for n in range(NumberOfLines):
            n = n+1

            Line = BaseLine.parallel_offset(self.LineSpacing*n,side, resolution=16, join_style=2, mitre_limit=1.0)
            if Line.geom_type != 'LineString' and shapely.__version__ >= '2.0.0:':
                try:
                    Line = ops.linemerge(Line)
                except:
                    Line = Line.geoms[0]
            if side == 'right':
                if shapely.__version__ <= '1.9.9:':
                    coords = [tuple(coord) for coord in list(Line.coords)][::-1]
                    Line = LineString(coords)
                else:
                    coords = [tuple(coord) for coord in list(Line.coords)][::-1]
                    coords.reverse()
                    Line = LineString(coords)


            LineBearing = InverseUTMBearing12
            if (n % 2) != 0:
                coords = [tuple(coord) for coord in list(Line.coords)][::-1]
                Line = LineString(coords)
                LineBearing = UTMBearing12

            FirstPoint = QgsPointXY(Line.coords[0][0], Line.coords[0][1])

            if self.LineSpacing <= self.CurveRadius*2:
                radius = self.LineSpacing/2
                x = LastPoint.x() + (radius * math.sin(UTMBearing23))
                y = LastPoint.y() + (radius * math.cos(UTMBearing23))
                CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
                x = x + (radius * math.sin(LineBearing))
                y = y + (radius * math.cos(LineBearing))
                CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
                Cur = Curve(CurveTarget,CurveCenter, self.MBES, self.SSS, self.SBP,
                          self.MAG, self.PB, self.Camera, self.OAS,
                          self.PlanSpeed, self.PlanHeight, self.Acoms,CurveSide)
                RowToAdd.ListOfGoTosOrCurves.append(Cur)
                CurveTarget = xformUTMToWGS84.transform(FirstPoint)
                Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                            self.MAG, self.PB, self.Camera, self.OAS,
                            self.PlanSpeed, self.PlanHeight, self.Acoms,CurveSide)
                RowToAdd.ListOfGoTosOrCurves.append(Cur)

            else:
                radius = self.CurveRadius
                x = LastPoint.x() + (radius * math.sin(UTMBearing23))
                y = LastPoint.y() + (radius * math.cos(UTMBearing23))
                CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
                x = x + (radius * math.sin(LineBearing))
                y = y + (radius * math.cos(LineBearing))
                CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
                Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                            self.MAG, self.PB, self.Camera, self.OAS,
                            self.PlanSpeed, self.PlanHeight, self.Acoms,CurveSide)
                RowToAdd.ListOfGoTosOrCurves.append(Cur)
                x = FirstPoint.x() + (radius * math.sin(InverseUTMBearing23))
                y = FirstPoint.y() + (radius * math.cos(InverseUTMBearing23))
                CurveCenter = QgsPointXY(x, y)
                x = CurveCenter.x() + (radius * math.sin(LineBearing))
                y = CurveCenter.y() + (radius * math.cos(LineBearing))
                GoToInCurve = xformUTMToWGS84.transform(QgsPointXY(x, y))
                GT = GoTo(GoToInCurve, self.MBES, self.SSS, self.SBP,
                          self.MAG, self.PB, self.Camera, self.OAS,
                          self.PlanSpeed, self.PlanHeight, self.Acoms, True,False,"GoTo")
                RowToAdd.ListOfGoTosOrCurves.append(GT)
                CurveCenter = xformUTMToWGS84.transform(CurveCenter)
                CurveTarget = xformUTMToWGS84.transform(FirstPoint)
                Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                            self.MAG, self.PB, self.Camera, self.OAS,
                            self.PlanSpeed, self.PlanHeight, self.Acoms,CurveSide)
                RowToAdd.ListOfGoTosOrCurves.append(Cur)

            if CurveSide == 'R':
                CurveSide = 'L'
            else:
                CurveSide = 'R'

            StopLoggingPoint = len(Line.coords[1:]) - 2
            r = 0
            for coords in Line.coords[1:]:
                point = xformUTMToWGS84.transform(QgsPointXY(coords[0], coords[1]))
                if r == 0 or r == StopLoggingPoint:
                    GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                self.MAG, self.PB, self.Camera, self.OAS,
                                self.PlanSpeed, self.PlanHeight, self.Acoms, False,True,"GoTo")
                else:
                    GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                              self.MAG, self.PB, self.Camera, self.OAS,
                              self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,"GoTo")
                r = r+1
                RowToAdd.ListOfGoTosOrCurves.append(GT)

            LastPoint = QgsPointXY(Line.coords[-1][0], Line.coords[-1][1])




        ###### CREATE THE INVERSE ROW TO BE STORED IN CASE OF REVERSE MANOUVRE CLICK#########
        Dist41 = math.dist(Point4UTM, Point1UTM)
        NumberOfLines = math.ceil(Dist41 / self.LineSpacing) - 1

        if (NumberOfLines +1) % 2 != 0:
            UTMBearing34 = 90 - math.degrees(math.atan2((Point4UTM.y() - Point3UTM.y()), (Point4UTM.x() - Point3UTM.x())))
            if UTMBearing34 < 0.0:
                UTMBearing34 += 360.0
            elif UTMBearing34 > 360.0:
                UTMBearing34 = UTMBearing34 - 360.0
            InverseUTMBearing34 = UTMBearing34 + 180
            if InverseUTMBearing34 > 360.0:
                InverseUTMBearing34 = InverseUTMBearing34 - 360.0
            UTMBearing34 = math.radians(UTMBearing34)
            InverseUTMBearing34 = math.radians(InverseUTMBearing34)
            x = Point3UTM.x() + (self.RunInRunOut * math.sin(InverseUTMBearing34))
            y = Point3UTM.y() + (self.RunInRunOut * math.cos(InverseUTMBearing34))
            RunInPoint = QgsPointXY(x, y)
            x = Point4UTM.x() + (self.RunInRunOut * math.sin(UTMBearing34))
            y = Point4UTM.y() + (self.RunInRunOut * math.cos(UTMBearing34))
            RunOutPoint = QgsPointXY(x, y)
            SurveyLine = self.densify_geometry(numpy.array(LineString([Point3UTM, Point4UTM]).coords),self.MaxDistance)

        else:
            if side == 'right':
                side = 'left'
            elif side == 'left':
                side = 'right'

            UTMBearing34 = 90 - math.degrees(
                math.atan2((Point3UTM.y() - Point4UTM.y()), (Point3UTM.x() - Point4UTM.x())))
            if UTMBearing34 < 0.0:
                UTMBearing34 += 360.0
            elif UTMBearing34 > 360.0:
                UTMBearing34 = UTMBearing34 - 360.0
            InverseUTMBearing34 = UTMBearing34 + 180
            if InverseUTMBearing34 > 360.0:
                InverseUTMBearing34 = InverseUTMBearing34 - 360.0
            UTMBearing34 = math.radians(UTMBearing34)
            InverseUTMBearing34 = math.radians(InverseUTMBearing34)
            x = Point4UTM.x() + (self.RunInRunOut * math.sin(InverseUTMBearing34))
            y = Point4UTM.y() + (self.RunInRunOut * math.cos(InverseUTMBearing34))
            RunInPoint = QgsPointXY(x, y)
            x = Point3UTM.x() + (self.RunInRunOut * math.sin(UTMBearing34))
            y = Point3UTM.y() + (self.RunInRunOut * math.cos(UTMBearing34))
            RunOutPoint = QgsPointXY(x, y)
            SurveyLine = self.densify_geometry(numpy.array(LineString([Point4UTM, Point3UTM]).coords),self.MaxDistance)


        SurveyLine = LineString(SurveyLine.tolist())
        TotalLineList = [RunInPoint]
        for point in list(SurveyLine.coords):
            TotalLineList.append(point)
        TotalLineList.append(RunOutPoint)
        BaseLine = LineString(TotalLineList)
        BaseLine = BaseLine.parallel_offset(self.LineSpacing / 3, side, resolution=16, join_style=2, mitre_limit=1.0)
        if BaseLine.geom_type != 'LineString' and shapely.__version__ >= '2.0.0:':
            try:
                BaseLine = ops.linemerge(BaseLine)
            except:
                BaseLine = BaseLine.geoms[0]

        if side == 'right':
            if shapely.__version__ <= '1.9.9:':
                coords = [tuple(coord) for coord in list(BaseLine.coords)][::-1]
                BaseLine = LineString(coords)
            else:
                coords = [tuple(coord) for coord in list(BaseLine.coords)][::-1]
                coords.reverse()
                BaseLine = LineString(coords)

        StopLoggingPoint = len(BaseLine.coords) - 2
        r = 0
        for coords in BaseLine.coords:
            point = xformUTMToWGS84.transform(QgsPointXY(coords[0], coords[1]))
            if r == 0:
                GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                          self.MAG, self.PB, self.Camera, self.OAS,
                          self.PlanSpeed, self.PlanHeight, self.Acoms, True, False, "GoTo")
            elif r == 1 or r == StopLoggingPoint:
                GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                          self.MAG, self.PB, self.Camera, self.OAS,
                          self.PlanSpeed, self.PlanHeight, self.Acoms, False, True, "GoTo")
            else:
                GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                          self.MAG, self.PB, self.Camera, self.OAS,
                          self.PlanSpeed, self.PlanHeight, self.Acoms, False, False, "GoTo")
            r = r + 1
            RowToAdd.InverseListOfGotosOrCurves.append(GT)

        Dist41 = math.dist(Point4UTM, Point1UTM)
        NumberOfLines = math.ceil(Dist41 / self.LineSpacing) - 1
        LastPoint = QgsPointXY(BaseLine.coords[-1][0], BaseLine.coords[-1][1])

        UTMBearing41 = 90 - math.degrees(math.atan2((Point1UTM.y() - Point4UTM.y()), (Point1UTM.x() - Point4UTM.x())))
        if UTMBearing41 < 0.0:
            UTMBearing41 += 360.0
        elif UTMBearing41 > 360.0:
            UTMBearing41 = UTMBearing41 - 360.0
        InverseUTMBearing41 = UTMBearing41 + 180
        if InverseUTMBearing41 > 360.0:
            InverseUTMBearing41 = InverseUTMBearing41 - 360.0
        UTMBearing41 = math.radians(UTMBearing41)
        InverseUTMBearing41 = math.radians(InverseUTMBearing41)
        if side == 'right':
            CurveSide = 'R'
        else:
            CurveSide = 'L'
        for n in range(NumberOfLines):
            n = n + 1
            Line = BaseLine.parallel_offset(self.LineSpacing * n, side, resolution=16, join_style=2, mitre_limit=1.0)
            if Line.geom_type != 'LineString' and shapely.__version__ >= '2.0.0:':
                try:
                    Line = ops.linemerge(Line)
                except:
                    Line = Line.geoms[0]
            if side == 'right':
                if shapely.__version__ <= '1.9.9:':
                    coords = [tuple(coord) for coord in list(Line.coords)][::-1]
                    Line = LineString(coords)
                else:
                    coords = [tuple(coord) for coord in list(Line.coords)][::-1]
                    coords.reverse()
                    Line = LineString(coords)

            LineBearing = InverseUTMBearing34
            if (n % 2) != 0:
                coords = [tuple(coord) for coord in list(Line.coords)][::-1]
                Line = LineString(coords)
                LineBearing = UTMBearing34
            FirstPoint = QgsPointXY(Line.coords[0][0], Line.coords[0][1])

            if self.LineSpacing <= self.CurveRadius * 2:
                radius = self.LineSpacing / 2
                x = LastPoint.x() + (radius * math.sin(UTMBearing41))
                y = LastPoint.y() + (radius * math.cos(UTMBearing41))
                CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
                x = x + (radius * math.sin(LineBearing))
                y = y + (radius * math.cos(LineBearing))
                CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
                Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                            self.MAG, self.PB, self.Camera, self.OAS,
                            self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
                RowToAdd.InverseListOfGotosOrCurves.append(Cur)
                CurveTarget = xformUTMToWGS84.transform(FirstPoint)
                Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                            self.MAG, self.PB, self.Camera, self.OAS,
                            self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
                RowToAdd.InverseListOfGotosOrCurves.append(Cur)

            else:
                radius = self.CurveRadius
                x = LastPoint.x() + (radius * math.sin(UTMBearing41))
                y = LastPoint.y() + (radius * math.cos(UTMBearing41))
                CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
                x = x + (radius * math.sin(LineBearing))
                y = y + (radius * math.cos(LineBearing))
                CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
                Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                            self.MAG, self.PB, self.Camera, self.OAS,
                            self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
                RowToAdd.InverseListOfGotosOrCurves.append(Cur)
                x = FirstPoint.x() + (radius * math.sin(InverseUTMBearing41))
                y = FirstPoint.y() + (radius * math.cos(InverseUTMBearing41))
                CurveCenter = QgsPointXY(x, y)
                x = CurveCenter.x() + (radius * math.sin(LineBearing))
                y = CurveCenter.y() + (radius * math.cos(LineBearing))
                GoToInCurve = xformUTMToWGS84.transform(QgsPointXY(x, y))
                GT = GoTo(GoToInCurve, self.MBES, self.SSS, self.SBP,
                          self.MAG, self.PB, self.Camera, self.OAS,
                          self.PlanSpeed, self.PlanHeight, self.Acoms, True, False, "GoTo")
                RowToAdd.InverseListOfGotosOrCurves.append(GT)
                CurveCenter = xformUTMToWGS84.transform(CurveCenter)
                CurveTarget = xformUTMToWGS84.transform(FirstPoint)
                Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                            self.MAG, self.PB, self.Camera, self.OAS,
                            self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
                RowToAdd.InverseListOfGotosOrCurves.append(Cur)

            if CurveSide == 'R':
                CurveSide = 'L'
            else:
                CurveSide = 'R'

            StopLoggingPoint = len(Line.coords[1:]) - 2
            r = 0
            for coords in Line.coords[1:]:
                point = xformUTMToWGS84.transform(QgsPointXY(coords[0], coords[1]))
                if r == 0 or r == StopLoggingPoint:
                    GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                              self.MAG, self.PB, self.Camera, self.OAS,
                              self.PlanSpeed, self.PlanHeight, self.Acoms, False, True, "GoTo")
                else:
                    GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                              self.MAG, self.PB, self.Camera, self.OAS,
                              self.PlanSpeed, self.PlanHeight, self.Acoms, False, False, "GoTo")
                r = r + 1
                RowToAdd.InverseListOfGotosOrCurves.append(GT)

            LastPoint = QgsPointXY(Line.coords[-1][0], Line.coords[-1][1])



        if self.Mission is not None:
            if self.selectedManouvres != []:
                self.Mission.ListOfManouvres.insert(self.selectedManouvres[0] + 1, RowToAdd)
                RowToSelect = self.selectedManouvres[0] + 1
            else:
                self.Mission.ListOfManouvres.append(RowToAdd)
                RowToSelect = len(self.Mission.ListOfManouvres) - 1
            self.MissionToBeSaved = True
            self.ShowAllMissions()
            self.DisplayMission()
            self.tableWidget.selectRow(RowToSelect)

    def CreateRowsFromSelectedFeature(self):
        if self.Mission is not None:
            layer = self.iface.activeLayer()
            if layer:
                if type(layer).__name__ == "QgsVectorLayer":
                    selection = layer.selectedFeatures()
                    if selection != []:
                        self.RetrieveManouvresSettings()
                        LayerEPSG = layer.crs().authid()
                        crsOrig = QgsCoordinateReferenceSystem(LayerEPSG)
                        crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
                        transformContext = QgsProject.instance().transformContext()
                        xformLayerToWGS84 = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                        feat = selection[0]
                        geom = feat.geometry()
                        if geom.type() == QgsWkbTypes.LineGeometry:
                            name = 'Rows'
                            layerFields = layer.fields().names()
                            id = 0
                            for field in layerFields:
                                if field.strip() == 'Name' or field.strip() == 'name' or field.strip() == 'NAME':
                                    attr = feat.attributes()[id]
                                    name = 'Rows - ' + str(attr)
                                    break
                                else:
                                    id = id + 1
                            dialog = WingLineCreator(self)
                            dialog.offset_doubleSpinBox.setValue(self.LineSpacing)
                            if dialog.exec():
                                Offset = float(dialog.Offset)
                                NStbdLines = dialog.NStbdLines
                                NPortLines = dialog.NPortLines
                                FirstTurn = dialog.FirstTurn
                                InvertLine = dialog.InvertLine
                                geomSingleType = QgsWkbTypes.isSingleType(geom.wkbType())
                                if geomSingleType:
                                    x = geom.asPolyline()
                                    LineList = []
                                    i = 0
                                    for p in x:
                                        if i == 0:
                                            point = xformLayerToWGS84.transform(p)
                                            UTMEPSG = self.get_utm_zoneEPSG(point.x(), point.y())
                                            crsDest = QgsCoordinateReferenceSystem(UTMEPSG)
                                            crsOrig = QgsCoordinateReferenceSystem(LayerEPSG)
                                            xformLayerToUTM = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                                            crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
                                            crsOrig = QgsCoordinateReferenceSystem(UTMEPSG)
                                            xformUTMToWGS84 = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                                        point = xformLayerToUTM.transform(p)
                                        LineList.append(point)
                                        i = i + 1
                                else:
                                    x = geom.asMultiPolyline()
                                    i = 0
                                    LineList = []
                                    for line in x:
                                        for p in line:
                                            if i == 0:
                                                point = xformLayerToWGS84.transform(p)
                                                UTMEPSG = self.get_utm_zoneEPSG(point.x(), point.y())
                                                crsDest = QgsCoordinateReferenceSystem(UTMEPSG)
                                                crsOrig = QgsCoordinateReferenceSystem(LayerEPSG)
                                                xformLayerToUTM = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                                                crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
                                                crsOrig = QgsCoordinateReferenceSystem(UTMEPSG)
                                                xformUTMToWGS84 = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
                                            point = xformLayerToUTM.transform(p)
                                            LineList.append(point)
                                            i = i + 1
                                if InvertLine == True:
                                    LineList.reverse()
                                densifiedLine = self.densify_geometry(numpy.array(LineString(LineList).coords),self.MaxDistance).tolist()
                                UTMRunInBearing = 90 - math.degrees(math.atan2((densifiedLine[0][1] - densifiedLine[1][1]),
                                                                            (densifiedLine[0][0] - densifiedLine[1][0])))
                                if UTMRunInBearing < 0.0:
                                    UTMRunInBearing += 360.0
                                UTMRunOutBearing = 90 - math.degrees(math.atan2((densifiedLine[-1][1] - densifiedLine[-2][1]),
                                                                            (densifiedLine[-1][0] - densifiedLine[-2][0])))
                                if UTMRunOutBearing < 0.0:
                                    UTMRunOutBearing += 360.0


                                if FirstTurn == 'Starboard':
                                    UTMRunOutCurveBearing = UTMRunOutBearing + 90
                                    if UTMRunOutCurveBearing > 360:
                                        UTMRunOutCurveBearing = UTMRunOutCurveBearing -360
                                    UTMRunInCurveBearing = UTMRunInBearing - 90
                                    if UTMRunInCurveBearing < 0.0:
                                        UTMRunInCurveBearing += 360.0
                                else:
                                    UTMRunOutCurveBearing = UTMRunOutBearing - 90
                                    if UTMRunOutCurveBearing < 0.0:
                                        UTMRunOutCurveBearing += 360.0
                                    UTMRunInCurveBearing = UTMRunInBearing + 90
                                    if UTMRunInCurveBearing > 360.0:
                                        UTMRunInCurveBearing =  UTMRunInCurveBearing - 360.0

                                UTMRunOutCurveBearing = math.radians(UTMRunOutCurveBearing)
                                UTMRunInCurveBearing = math.radians(UTMRunInCurveBearing)
                                UTMRunInBearing = math.radians(UTMRunInBearing)
                                UTMRunOutBearing = math.radians(UTMRunOutBearing)
                                RunInPointX = densifiedLine[0][0] + (self.RunInRunOut * math.sin(UTMRunInBearing))
                                RunInPointY = densifiedLine[0][1] + (self.RunInRunOut * math.cos(UTMRunInBearing))
                                RunOutPointX = densifiedLine[-1][0] + (self.RunInRunOut * math.sin(UTMRunOutBearing))
                                RunOutPointY = densifiedLine[-1][1] + (self.RunInRunOut * math.cos(UTMRunOutBearing))
                                densifiedLine.insert(0,(RunInPointX,RunInPointY))
                                densifiedLine.append((RunOutPointX, RunOutPointY))
                                densifiedLine = LineString(densifiedLine)

                                StbdLines = []
                                for n in range(NStbdLines):
                                    n = n+1
                                    Line = densifiedLine.parallel_offset(Offset * n, 'right', resolution=16,
                                                                        join_style=2, mitre_limit=1.0)

                                    if Line.geom_type == 'MultiLineString':
                                        ret = QMessageBox.information(self, "Info", 'A problem occured with the selected line, try to use a shorter one or transform it from multi part to singlepart',
                                                                      QMessageBox.Ok)
                                        return

                                    coords = [tuple(coord) for coord in list(Line.coords)][::-1]

                                    if shapely.__version__ > '1.9.9:':
                                        coords.reverse()

                                    Line = LineString(coords)
                                    StbdLines.append(Line)

                                PortLines = []
                                for n in range(NPortLines):
                                    n = n + 1
                                    Line = densifiedLine.parallel_offset(Offset * n, 'left', resolution=16,
                                                                        join_style=2, mitre_limit=1.0)

                                    if Line.geom_type == 'MultiLineString':
                                        ret = QMessageBox.information(self, "Info",
                                                                      'A problem occured with the selected line, try to use a shorter one or transform it from multi part to singlepart',
                                                                      QMessageBox.Ok)
                                        return

                                    PortLines.append(Line)

                                if FirstTurn == 'Starboard':
                                    PortLines.reverse()
                                    LineList = PortLines + [densifiedLine] + StbdLines
                                    PortLines.reverse()
                                    StbdLines.reverse()
                                    ReverseLineList = StbdLines + [densifiedLine] + PortLines
                                else:
                                    StbdLines.reverse()
                                    LineList = StbdLines + [densifiedLine] + PortLines
                                    PortLines.reverse()
                                    StbdLines.reverse()
                                    ReverseLineList = PortLines + [densifiedLine] + StbdLines

                                RowToAdd = Rows([], self.PlanSpeed, self.MBES, self.SSS, self.SBP, self.MAG, self.PB,
                                                self.Camera, self.OAS, self.PlanHeight, self.Acoms,name,[])

                                StopLoggingPoint = len(LineList[0].coords)-2
                                r = 0
                                for coords in LineList[0].coords:
                                    point = xformUTMToWGS84.transform(QgsPointXY(coords[0], coords[1]))
                                    if r == 0:
                                        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                  self.MAG, self.PB, self.Camera, self.OAS,
                                                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False, "GoTo")
                                    elif r == 1 or r == StopLoggingPoint:
                                        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                self.MAG, self.PB, self.Camera, self.OAS,
                                                self.PlanSpeed, self.PlanHeight, self.Acoms, False,True,"GoTo")
                                    else:
                                        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                  self.MAG, self.PB, self.Camera, self.OAS,
                                                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,"GoTo")
                                    r = r+1
                                    RowToAdd.ListOfGoTosOrCurves.append(GT)
                                LastPoint = QgsPointXY(LineList[0].coords[-1][0], LineList[0].coords[-1][1])

                                if FirstTurn == 'Starboard':
                                    CurveSide = 'R'
                                else:
                                    CurveSide = 'L'
                                n = 0
                                for line in LineList[1:]:
                                    if n % 2 == 0:
                                        line = LineString([tuple(coord) for coord in list(line.coords)][::-1])
                                        TargetBearing = UTMRunOutBearing
                                        CurveCenterBearing = UTMRunOutCurveBearing
                                    else:
                                        TargetBearing = UTMRunInBearing
                                        CurveCenterBearing = UTMRunInCurveBearing

                                    FirstPoint = QgsPointXY(line.coords[0][0], line.coords[0][1])
                                    if Offset <= self.CurveRadius * 2:
                                        radius = Offset / 2
                                        x = LastPoint.x() + (radius * math.sin(CurveCenterBearing))
                                        y = LastPoint.y() + (radius * math.cos(CurveCenterBearing))
                                        CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
                                        x = x + (radius * math.sin(TargetBearing))
                                        y = y + (radius * math.cos(TargetBearing))
                                        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
                                        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                                                    self.MAG, self.PB, self.Camera, self.OAS,
                                                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
                                        RowToAdd.ListOfGoTosOrCurves.append(Cur)
                                        CurveTarget = xformUTMToWGS84.transform(FirstPoint)
                                        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                                                    self.MAG, self.PB, self.Camera, self.OAS,
                                                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
                                        RowToAdd.ListOfGoTosOrCurves.append(Cur)
                                    else:
                                        radius = self.CurveRadius
                                        x = LastPoint.x() + (radius * math.sin(CurveCenterBearing))
                                        y = LastPoint.y() + (radius * math.cos(CurveCenterBearing))
                                        CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
                                        x = x + (radius * math.sin(TargetBearing))
                                        y = y + (radius * math.cos(TargetBearing))
                                        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
                                        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                                                    self.MAG, self.PB, self.Camera, self.OAS,
                                                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
                                        RowToAdd.ListOfGoTosOrCurves.append(Cur)
                                        x = FirstPoint.x() + (radius * math.sin((CurveCenterBearing + math.pi) % (2*math.pi)))
                                        y = FirstPoint.y() + (radius * math.cos((CurveCenterBearing + math.pi) % (2*math.pi)))
                                        CurveCenter = QgsPointXY(x, y)
                                        x = CurveCenter.x() + (radius * math.sin(TargetBearing))
                                        y = CurveCenter.y() + (radius * math.cos(TargetBearing))
                                        GoToInCurve = xformUTMToWGS84.transform(QgsPointXY(x, y))
                                        GT = GoTo(GoToInCurve, self.MBES, self.SSS, self.SBP,
                                                  self.MAG, self.PB, self.Camera, self.OAS,
                                                  self.PlanSpeed, self.PlanHeight, self.Acoms, True,False,"GoTo")
                                        RowToAdd.ListOfGoTosOrCurves.append(GT)
                                        CurveCenter = xformUTMToWGS84.transform(CurveCenter)
                                        CurveTarget = xformUTMToWGS84.transform(FirstPoint)
                                        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                                                    self.MAG, self.PB, self.Camera, self.OAS,
                                                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
                                        RowToAdd.ListOfGoTosOrCurves.append(Cur)

                                    if CurveSide == 'R':
                                        CurveSide = 'L'
                                    else:
                                        CurveSide = 'R'
                                    n = n +1

                                    StopLoggingPoint = len(line.coords[1:]) - 2
                                    r = 0
                                    for coords in line.coords[1:]:
                                        point = xformUTMToWGS84.transform(QgsPointXY(coords[0], coords[1]))
                                        if r == 0 or r == StopLoggingPoint:
                                            GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                        self.MAG, self.PB, self.Camera, self.OAS,
                                                        self.PlanSpeed, self.PlanHeight, self.Acoms, False,True,"GoTo")
                                        else:
                                            GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                      self.MAG, self.PB, self.Camera, self.OAS,
                                                      self.PlanSpeed, self.PlanHeight, self.Acoms, False, False,"GoTo")
                                        r = r+1

                                        RowToAdd.ListOfGoTosOrCurves.append(GT)
                                    LastPoint = QgsPointXY(line.coords[-1][0], line.coords[-1][1])





                                ####CREATE INVERSE ROW ######
                                StopLoggingPoint = len(ReverseLineList[0].coords) - 2
                                r = 0
                                for coords in ReverseLineList[0].coords:
                                    point = xformUTMToWGS84.transform(QgsPointXY(coords[0], coords[1]))
                                    if r == 0:
                                        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                  self.MAG, self.PB, self.Camera, self.OAS,
                                                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False, "GoTo")

                                    elif r == 1 or r == StopLoggingPoint:
                                        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                  self.MAG, self.PB, self.Camera, self.OAS,
                                                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, True, "GoTo")
                                    else:
                                        GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                  self.MAG, self.PB, self.Camera, self.OAS,
                                                  self.PlanSpeed, self.PlanHeight, self.Acoms, False, False, "GoTo")
                                    r = r + 1
                                    RowToAdd.InverseListOfGotosOrCurves.append(GT)
                                LastPoint = QgsPointXY(ReverseLineList[0].coords[-1][0], ReverseLineList[0].coords[-1][1])

                                if FirstTurn == 'Starboard':
                                    CurveSide = 'L'
                                else:
                                    CurveSide = 'R'
                                n = 0
                                for line in ReverseLineList[1:]:
                                    if n % 2 == 0:
                                        line = LineString([tuple(coord) for coord in list(line.coords)][::-1])
                                        TargetBearing = UTMRunOutBearing #+ math.pi) % (2 * math.pi)
                                        CurveCenterBearing = (UTMRunOutCurveBearing + math.pi) % (2 * math.pi)
                                    else:

                                        TargetBearing = UTMRunInBearing
                                        CurveCenterBearing = (UTMRunInCurveBearing + math.pi) % (2 * math.pi)


                                    FirstPoint = QgsPointXY(line.coords[0][0], line.coords[0][1])
                                    if Offset <= self.CurveRadius * 2:
                                        radius = Offset / 2
                                        x = LastPoint.x() + (radius * math.sin(CurveCenterBearing))
                                        y = LastPoint.y() + (radius * math.cos(CurveCenterBearing))
                                        CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
                                        x = x + (radius * math.sin(TargetBearing))
                                        y = y + (radius * math.cos(TargetBearing))
                                        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
                                        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                                                    self.MAG, self.PB, self.Camera, self.OAS,
                                                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
                                        RowToAdd.InverseListOfGotosOrCurves.append(Cur)
                                        CurveTarget = xformUTMToWGS84.transform(FirstPoint)
                                        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                                                    self.MAG, self.PB, self.Camera, self.OAS,
                                                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
                                        RowToAdd.InverseListOfGotosOrCurves.append(Cur)
                                    else:
                                        radius = self.CurveRadius
                                        x = LastPoint.x() + (radius * math.sin(CurveCenterBearing))
                                        y = LastPoint.y() + (radius * math.cos(CurveCenterBearing))
                                        CurveCenter = xformUTMToWGS84.transform(QgsPointXY(x, y))
                                        x = x + (radius * math.sin(TargetBearing))
                                        y = y + (radius * math.cos(TargetBearing))
                                        CurveTarget = xformUTMToWGS84.transform(QgsPointXY(x, y))
                                        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                                                    self.MAG, self.PB, self.Camera, self.OAS,
                                                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
                                        RowToAdd.InverseListOfGotosOrCurves.append(Cur)
                                        x = FirstPoint.x() + (
                                                    radius * math.sin((CurveCenterBearing + math.pi) % (2 * math.pi)))
                                        y = FirstPoint.y() + (
                                                    radius * math.cos((CurveCenterBearing + math.pi) % (2 * math.pi)))
                                        CurveCenter = QgsPointXY(x, y)
                                        x = CurveCenter.x() + (radius * math.sin(TargetBearing))
                                        y = CurveCenter.y() + (radius * math.cos(TargetBearing))
                                        GoToInCurve = xformUTMToWGS84.transform(QgsPointXY(x, y))
                                        GT = GoTo(GoToInCurve, self.MBES, self.SSS, self.SBP,
                                                  self.MAG, self.PB, self.Camera, self.OAS,
                                                  self.PlanSpeed, self.PlanHeight, self.Acoms, True, False, "GoTo")
                                        RowToAdd.InverseListOfGotosOrCurves.append(GT)
                                        CurveCenter = xformUTMToWGS84.transform(CurveCenter)
                                        CurveTarget = xformUTMToWGS84.transform(FirstPoint)
                                        Cur = Curve(CurveTarget, CurveCenter, self.MBES, self.SSS, self.SBP,
                                                    self.MAG, self.PB, self.Camera, self.OAS,
                                                    self.PlanSpeed, self.PlanHeight, self.Acoms, CurveSide)
                                        RowToAdd.InverseListOfGotosOrCurves.append(Cur)

                                    if CurveSide == 'R':
                                        CurveSide = 'L'
                                    else:
                                        CurveSide = 'R'
                                    n = n + 1

                                    StopLoggingPoint = len(line.coords[1:]) - 2
                                    r = 0
                                    for coords in line.coords[1:]:
                                        point = xformUTMToWGS84.transform(QgsPointXY(coords[0], coords[1]))
                                        if r == 0 or r == StopLoggingPoint:
                                            GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                      self.MAG, self.PB, self.Camera, self.OAS,
                                                      self.PlanSpeed, self.PlanHeight, self.Acoms, False, True, "GoTo")
                                        else:
                                            GT = GoTo(point, self.MBES, self.SSS, self.SBP,
                                                      self.MAG, self.PB, self.Camera, self.OAS,
                                                      self.PlanSpeed, self.PlanHeight, self.Acoms, False, False, "GoTo")
                                        r = r + 1

                                        RowToAdd.InverseListOfGotosOrCurves.append(GT)
                                    LastPoint = QgsPointXY(line.coords[-1][0], line.coords[-1][1])


                                if self.selectedManouvres != []:
                                    self.Mission.ListOfManouvres.insert(self.selectedManouvres[0] + 1, RowToAdd)
                                    RowToSelect = self.selectedManouvres[0] + 1
                                else:
                                    self.Mission.ListOfManouvres.append(RowToAdd)
                                    RowToSelect = len(self.Mission.ListOfManouvres) - 1
                                self.MissionToBeSaved = True
                                self.ShowAllMissions()
                                self.DisplayMission()
                                self.tableWidget.selectRow(RowToSelect)

    def RetrieveManouvresSettings(self):
        self.MissionCriticals = {'MBES':[],'SSS':[],'SBP':[],'MAG':[],'PB':[],'CAM':[],'OAS':[]}
        self.MissionCriticals['MBES'].append(self.MBES_MC_checkBox.isChecked())
        self.MissionCriticals['SSS'].append(self.SSS_MC_checkBox.isChecked())
        self.MissionCriticals['SBP'].append(self.SBP_MC_checkBox.isChecked())
        self.MissionCriticals['MAG'].append(self.MAG_MC_checkBox.isChecked())
        self.MissionCriticals['PB'].append(self.PB_MC_checkBox.isChecked())
        self.MissionCriticals['CAM'].append(self.CAM_MC_checkBox.isChecked())
        self.MissionCriticals['OAS'].append(self.OAS_MC_checkBox.isChecked())

        self.SafeAltitude = self.SafeAltitude_doubleSpinBox.value()
        self.MissionEndBehavior = self.MissionEndBehavior_comboBox.currentIndex()
        self.LowBattery = self.LowBattery_doubleSpinBox.value()
        self.CurveRadius = self.CurveRadius_doubleSpinBox.value()
        self.PlanSpeed = self.PlanSpeed_doubleSpinBox.value()
        self.PlanHeight= (self.PlanHeight_doubleSpinBox.value(),self.PlanHeight_comboBox.currentIndex())
        self.LineSpacing = self.LineSpacingSet_doubleSpinBox.value()
        self.RunInRunOut = self.RunInRunOut_spinBox.value()
        self.MaxDistance = self.MaxDistance_spinBox.value()
        self.StationKeepingDuration = self.StationKeepingDuration_spinBox.value()

        self.Acoms = Acoms(self.Acoms_AutoSend_checkBox.isChecked(),
                           self.Acoms_Interval_spinBox.value(),
                           self.Acoms_Repetitions_spinBox.value(),
                           self.Acoms_CurveOnly_checkBox.isChecked())

        self.MBES = MBES(self.MBES_Active_checkBox.isChecked(),
                         self.MBES_OnLinesOnly_checkBox.isChecked(),
                         self.MBES_Angle_spinBox.value(),
                         self.MBES_OpMode_comboBox.currentIndex(),
                         self.MBES_GateMode_comboBox.currentIndex(),
                         self.MBES_UpperGate_spinBox.value(),
                         self.MBES_LowerGate_spinBox.value(),
                         self.MBES_BeamDistrib_comboBox.currentIndex(),
                         self.MBES_TxFrequency_spinBox.value(),
                         self.MBES_TxBandwith_spinBox.value(),
                         self.MBES_TxAmplitude_spinBox.value(),
                         self.MBES_TxSweeplenght_spinBox.value(),
                         self.MBES_Matchfilter_comboBox.currentIndex(),
                         self.MBES_BeamNumber_comboBox.currentIndex())

        self.SSS = SSS(self.SSS_Active_checkBox.isChecked(),
                       self.SSS_OnLinesOnly_checkBox.isChecked(),
                       self.SSS_Range_spinBox.value(),
                       self.SSS_OpMode_comboBox.currentIndex(),
                       self.SSS_Gain_comboBox.currentIndex())

        self.SBP = SBP(self.SBP_Active_checkBox.isChecked(),
                       self.SBP_OnLinesOnly_checkBox.isChecked(),
                       self.SBP_Range_spinBox.value(),
                       self.LFGain_spinBox.value(),
                       self.LFTreshold_spinBox.value(),
                       self.LFContrast_spinBox.value(),
                       self.HFGain_spinBox.value(),
                       self.HFTreshold_spinBox.value(),
                       self.HFContrast_spinBox.value())

        self.Camera = Camera(self.CAM_Active_checkBox.isChecked(),
                             self.CAM_Fps_spinBox.value(),
                             self.CAM_ShowVideo_comboBox.currentIndex(),
                             self.CAM_Gain_spinBox.value(),
                             self.CAM_Format_comboBox.currentIndex(),
                             self.CAM_ImgCompression_comboBox.currentIndex(),
                             self.CAM_ShutterTime_spinBox.value(),
                             self.CAM_Strobe_comboBox.currentIndex(),
                             self.CAM_StrobeIntensity_spinBox.value(),
                             self.CAM_OnLinesOnly_checkBox.isChecked())

        self.MAG = MAG(self.MAG_Active_checkBox.isChecked(),self.MAG_OnLinesOnly_checkBox.isChecked())
        self.PB = PlanBlue(self.PB_Active_checkBox.isChecked(), self.PB_OnLinesOnly_checkBox.isChecked())
        self.OAS = OAS(self.OAS_Active_checkBox.isChecked())

    def MBESCalculator(self):
        dialog = LineSpacingCalculator(self)
        if self.PlanHeight_comboBox.currentIndex() == 0:
            dialog.Altitude_doubleSpinBox.setValue(self.PlanHeight_doubleSpinBox.value())
        dialog.MBESAngle_spinBox.setValue(self.MBES_Angle_spinBox.value())
        if dialog.exec():
            self.MBES_Angle_spinBox.setValue(dialog.MbesAngle)
            if self.PlanHeight_comboBox.currentIndex() == 0:
                self.PlanHeight_doubleSpinBox.setValue(dialog.Height)
            self.LineSpacingSet_doubleSpinBox.setValue(dialog.LineSpacing)

    def CamCalculator(self):
        dialog = CameraCalculator(self)
        if self.PlanHeight_comboBox.currentIndex() == 0:
            dialog.Altitude_doubleSpinBox.setValue(self.PlanHeight_doubleSpinBox.value())
        dialog.Fps_spinBox.setValue(self.CAM_Fps_spinBox.value())
        if dialog.exec():
            if self.PlanHeight_comboBox.currentIndex() == 0:
                self.PlanHeight_doubleSpinBox.setValue(dialog.Height)
            self.LineSpacingSet_doubleSpinBox.setValue(dialog.LineSpacing)
            self.CAM_Fps_spinBox.setValue(dialog.Fps)
            self.PlanSpeed_doubleSpinBox.setValue(dialog.Speed)

    def UpdateTransformation(self):
        crsDest = QgsCoordinateReferenceSystem("EPSG:4326")
        crsOrig = QgsProject.instance().crs()
        transformContext = QgsProject.instance().transformContext()
        self.xformMapCrsToWGS84 = QgsCoordinateTransform(crsOrig, crsDest, transformContext)
        self.ShowAllMissions()
        self.DisplayMission()
        self.DisplayManouvres()

    def get_utm_zoneEPSG(self,longitude,latitude):
        Zone = str((int(1 + (longitude + 180.0) / 6.0)))

        if (latitude < 0.0):
            NorthOrSouth = '7'
        else:
            NorthOrSouth = '6'

        return('EPSG:32'+NorthOrSouth+Zone)

    def densify_geometry(self,geom,max_distance):
        N = len(geom) - 1
        dxdy = geom[1:, :] - geom[:-1, :]
        leng = numpy.sqrt(numpy.einsum('ij,ij->i', dxdy, dxdy))
        steps = leng / max_distance
        deltas = dxdy / (steps.reshape(-1, 1))
        pnts = numpy.empty((N,), dtype='O')
        for i in range(N):
            num = numpy.arange(steps[i])
            pnts[i] = numpy.array((num, num)).T * deltas[i] + geom[i]
        geom0 = geom[-1].reshape(1, -1)
        return numpy.concatenate((*pnts, geom0), axis=0)

    def KtsToMs(self,kts):
        return round(kts * 0.51444,1)

    def degToCompass(self,num):
        val = int((num / 22.5) + .5)
        arr = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"]
        return arr[(val % 16)]

    def resetPlugin(self):
        if self.MissionToBeSaved == True:
            ret = QMessageBox.information(self, "Info", 'Current mission was modified, do you want to save it?',
                                          QMessageBox.Yes, QMessageBox.No)
            if ret == QMessageBox.Yes:
                self.SaveMission()
            self.MissionToBeSaved = False
        self.EstDuration_label.setText('Est. duration:')
        self.ShowAllMissions_checkBox.setChecked(False)

        self.MissionsFileList = []
        self.Mission = None
        self.selectedManouvres = []

        self.Missions_comboBox.clear()
        self.tableWidget.clearContents()
        self.tableWidget.setRowCount(0)
        self.LinePlanRubber.reset(QgsWkbTypes.LineGeometry)
        self.scrollArea_5.setEnabled(False)

        try:
            self.canvas.scene().removeItem(self.StartPlanMarker)
            self.canvas.scene().removeItem(self.EndPlanMarker)
        except:
            pass

        if self.manouvreRbDict is not None:
            Id = 0
            for rubber in self.manouvreRbDict:
                self.canvas.scene().removeItem(self.manouvreRbDict[Id])
                Id = Id + 1
        self.manouvreRbDict = None

        if self.RunInRunOutRbDict is not None:
            Id = 0
            for vertex in self.RunInRunOutRbDict:
                self.canvas.scene().removeItem(self.RunInRunOutRbDict[Id])
                Id = Id + 1
        self.RunInRunOutRbDict = None

        self.MBES_toolButton.setStyleSheet("")
        self.SBP_toolButton.setStyleSheet("")
        self.SSS_toolButton.setStyleSheet("")
        self.MAG_toolButton.setStyleSheet("")
        self.PB_toolButton.setStyleSheet("")
        self.OAS_toolButton.setStyleSheet("")
        self.CAM_toolButton.setStyleSheet("")
        self.ACOMS_toolButton.setStyleSheet("")

    def closeEvent(self, event):
        self.resetPlugin()
        self.closingPlugin.emit()
        event.accept()
